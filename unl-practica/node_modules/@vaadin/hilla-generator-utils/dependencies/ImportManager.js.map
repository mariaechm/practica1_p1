{"mappings":"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","names":["#collator","#map","collator: Intl.Collator","path: string","specifier: string","isType?: boolean","uniqueId?: Identifier","name: string","source: ts.SourceFile"],"sources":["/opt/agent/work/1af72d8adc613024/hilla/packages/ts/generator-utils/src/dependencies/ImportManager.ts"],"sourcesContent":["import ts, { type Identifier, type ImportDeclaration, type Statement } from 'typescript';\nimport createFullyUniqueIdentifier from '../createFullyUniqueIdentifier.js';\nimport type CodeConvertable from './CodeConvertable.js';\nimport StatementRecordManager, { type StatementRecord } from './StatementRecordManager.js';\nimport { createDependencyRecord, type DependencyRecord } from './utils.js';\n\nexport class NamedImportManager extends StatementRecordManager<ImportDeclaration> {\n  readonly #collator: Intl.Collator;\n  readonly #map = new Map<string, Map<string, DependencyRecord>>();\n\n  constructor(collator: Intl.Collator) {\n    super(collator);\n    this.#collator = collator;\n  }\n\n  get size(): number {\n    return this.#map.size;\n  }\n\n  add(path: string, specifier: string, isType?: boolean, uniqueId?: Identifier): Identifier {\n    const record = createDependencyRecord(uniqueId ?? createFullyUniqueIdentifier(specifier), isType);\n\n    if (this.#map.has(path)) {\n      this.#map.get(path)!.set(specifier, record);\n    } else {\n      this.#map.set(path, new Map([[specifier, record]]));\n    }\n\n    return record.id;\n  }\n\n  remove(path: string, specifier: string): void {\n    const specifiers = this.#map.get(path);\n\n    if (specifiers) {\n      specifiers.delete(specifier);\n\n      if (specifiers.size === 0) {\n        this.#map.delete(path);\n      }\n    }\n  }\n\n  override clear(): void {\n    this.#map.clear();\n  }\n\n  getIdentifier(path: string, specifier: string): Identifier | undefined {\n    return this.#map.get(path)?.get(specifier)?.id;\n  }\n\n  iter(): IterableIterator<readonly [path: string, specifier: string, id: Identifier, isType: boolean]> {\n    return this[Symbol.iterator]();\n  }\n\n  isType(path: string, specifier: string): boolean | undefined {\n    return this.#map.get(path)?.get(specifier)?.isType;\n  }\n\n  paths(): IterableIterator<string> {\n    return this.#map.keys();\n  }\n\n  *specifiers(): IterableIterator<readonly [path: string, specifier: string]> {\n    for (const [path, specifiers] of this.#map) {\n      for (const specifier of specifiers.keys()) {\n        yield [path, specifier];\n      }\n    }\n  }\n\n  override *statementRecords(): IterableIterator<StatementRecord<ImportDeclaration>> {\n    for (const [path, specifiers] of this.#map) {\n      const names = [...specifiers.keys()];\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      names.sort(this.#collator.compare);\n\n      const isTypeOnly = names.every((name) => specifiers.get(name)!.isType);\n\n      yield [\n        path,\n        ts.factory.createImportDeclaration(\n          undefined,\n          ts.factory.createImportClause(\n            isTypeOnly,\n            undefined,\n            ts.factory.createNamedImports(\n              names.map((name) => {\n                const { id, isType } = specifiers.get(name)!;\n                return ts.factory.createImportSpecifier(\n                  isTypeOnly ? false : isType,\n                  ts.factory.createIdentifier(name),\n                  id,\n                );\n              }),\n            ),\n          ),\n          ts.factory.createStringLiteral(path),\n        ),\n      ];\n    }\n  }\n\n  *[Symbol.iterator](): IterableIterator<readonly [path: string, specifier: string, id: Identifier, isType: boolean]> {\n    for (const [path, specifiers] of this.#map) {\n      for (const [specifier, { id, isType }] of specifiers) {\n        yield [path, specifier, id, isType];\n      }\n    }\n  }\n}\n\nexport class NamespaceImportManager extends StatementRecordManager<ImportDeclaration> {\n  readonly #map = new Map<string, Identifier>();\n\n  get size(): number {\n    return this.#map.size;\n  }\n\n  add(path: string, name: string, uniqueId?: Identifier): Identifier {\n    const id = uniqueId ?? createFullyUniqueIdentifier(name);\n    this.#map.set(path, id);\n    return id;\n  }\n\n  override clear(): void {\n    this.#map.clear();\n  }\n\n  getIdentifier(path: string): Identifier | undefined {\n    return this.#map.get(path);\n  }\n\n  iter(): IterableIterator<readonly [path: string, id: Identifier]> {\n    return this[Symbol.iterator]();\n  }\n\n  paths(): IterableIterator<string> {\n    return this.#map.keys();\n  }\n\n  override *statementRecords(): IterableIterator<StatementRecord<ImportDeclaration>> {\n    for (const [path, id] of this.#map) {\n      yield [\n        path,\n        ts.factory.createImportDeclaration(\n          undefined,\n          ts.factory.createImportClause(false, undefined, ts.factory.createNamespaceImport(id)),\n          ts.factory.createStringLiteral(path),\n        ),\n      ];\n    }\n  }\n\n  remove(path: string): void {\n    this.#map.delete(path);\n  }\n\n  *[Symbol.iterator](): IterableIterator<readonly [path: string, id: Identifier]> {\n    for (const [path, id] of this.#map) {\n      yield [path, id];\n    }\n  }\n}\n\nexport class DefaultImportManager extends StatementRecordManager<ImportDeclaration> {\n  readonly #map = new Map<string, DependencyRecord>();\n\n  get size(): number {\n    return this.#map.size;\n  }\n\n  add(path: string, name: string, isType?: boolean, uniqueId?: Identifier): Identifier {\n    const id = uniqueId ?? createFullyUniqueIdentifier(name);\n    this.#map.set(path, createDependencyRecord(id, isType));\n    return id;\n  }\n\n  getIdentifier(path: string): Identifier | undefined {\n    return this.#map.get(path)?.id;\n  }\n\n  remove(path: string): void {\n    if (this.#map.has(path)) {\n      this.#map.delete(path);\n    }\n  }\n\n  override clear(): void {\n    this.#map.clear();\n  }\n\n  iter(): IterableIterator<readonly [path: string, id: Identifier, isType: boolean]> {\n    return this[Symbol.iterator]();\n  }\n\n  isType(path: string): boolean | undefined {\n    return this.#map.get(path)?.isType;\n  }\n\n  paths(): IterableIterator<string> {\n    return this.#map.keys();\n  }\n\n  override *statementRecords(): IterableIterator<StatementRecord<ImportDeclaration>> {\n    for (const [path, { id, isType }] of this.#map) {\n      yield [\n        path,\n        ts.factory.createImportDeclaration(\n          undefined,\n          ts.factory.createImportClause(isType, id, undefined),\n          ts.factory.createStringLiteral(path),\n        ),\n      ];\n    }\n  }\n\n  *[Symbol.iterator](): IterableIterator<readonly [path: string, id: Identifier, isType: boolean]> {\n    for (const [path, { id, isType }] of this.#map) {\n      yield [path, id, isType];\n    }\n  }\n}\n\nexport default class ImportManager implements CodeConvertable<readonly Statement[]> {\n  readonly default: DefaultImportManager;\n  readonly named: NamedImportManager;\n  readonly namespace: NamespaceImportManager;\n\n  readonly #collator: Intl.Collator;\n\n  constructor(collator: Intl.Collator) {\n    this.default = new DefaultImportManager(collator);\n    this.named = new NamedImportManager(collator);\n    this.namespace = new NamespaceImportManager(collator);\n    this.#collator = collator;\n  }\n\n  get size(): number {\n    return this.default.size + this.named.size + this.namespace.size;\n  }\n\n  toCode(): readonly Statement[] {\n    const records = [\n      ...this.default.statementRecords(),\n      ...this.named.statementRecords(),\n      ...this.namespace.statementRecords(),\n    ];\n    records.sort(StatementRecordManager.createComparator(this.#collator));\n\n    return records.map(([, statement]) => statement);\n  }\n\n  fromCode(source: ts.SourceFile): void {\n    this.default.clear();\n    this.named.clear();\n    this.namespace.clear();\n\n    const imports = source.statements.filter((statement): statement is ImportDeclaration =>\n      ts.isImportDeclaration(statement),\n    );\n\n    for (const { importClause, moduleSpecifier } of imports) {\n      if (!importClause) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      const { name, namedBindings } = importClause;\n      const path = (moduleSpecifier as ts.StringLiteral).text;\n\n      if (namedBindings) {\n        if (ts.isNamespaceImport(namedBindings)) {\n          this.namespace.add(path, namedBindings.name.text, namedBindings.name);\n        } else {\n          for (const { isTypeOnly, name: specifier } of namedBindings.elements) {\n            this.named.add(path, specifier.text, isTypeOnly, specifier);\n          }\n        }\n      } else if (name) {\n        this.default.add(path, name.text, importClause.isTypeOnly, name);\n      }\n    }\n  }\n}\n"],"version":3}