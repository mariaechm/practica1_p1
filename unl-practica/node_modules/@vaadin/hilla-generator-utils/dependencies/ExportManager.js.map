{"mappings":"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","names":["#collator","#map","collator: Intl.Collator","name: string","isType?: boolean","uniqueId?: Identifier","path: string","#id","id: Identifier | string","result: Statement[]"],"sources":["/opt/agent/work/1af72d8adc613024/hilla/packages/ts/generator-utils/src/dependencies/ExportManager.ts"],"sourcesContent":["import ts, { type ExportAssignment, type ExportDeclaration, type Identifier, type Statement } from 'typescript';\nimport createFullyUniqueIdentifier from '../createFullyUniqueIdentifier.js';\nimport type CodeConvertable from './CodeConvertable.js';\nimport StatementRecordManager, { type StatementRecord } from './StatementRecordManager.js';\nimport { createDependencyRecord, type DependencyRecord } from './utils.js';\n\nexport class NamedExportManager implements CodeConvertable<ExportDeclaration | undefined> {\n  readonly #collator: Intl.Collator;\n  readonly #map = new Map<string, DependencyRecord>();\n\n  get size(): number {\n    return this.#map.size;\n  }\n\n  constructor(collator: Intl.Collator) {\n    this.#collator = collator;\n  }\n\n  add(name: string, isType?: boolean, uniqueId?: Identifier): Identifier {\n    const id = uniqueId ?? createFullyUniqueIdentifier(name);\n    this.#map.set(name, createDependencyRecord(id, isType));\n    return id;\n  }\n\n  getIdentifier(name: string): Identifier | undefined {\n    return this.#map.get(name)?.id;\n  }\n\n  *identifiers(): IterableIterator<readonly [id: Identifier, isType: boolean]> {\n    for (const { id, isType } of this.#map.values()) {\n      yield [id, isType];\n    }\n  }\n\n  isType(name: string): boolean | undefined {\n    return this.#map.get(name)?.isType;\n  }\n\n  names(): IterableIterator<string> {\n    return this.#map.keys();\n  }\n\n  toCode(): ExportDeclaration | undefined {\n    if (this.#map.size === 0) {\n      return undefined;\n    }\n\n    const names = [...this.#map.keys()];\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    names.sort(this.#collator.compare);\n\n    return ts.factory.createExportDeclaration(\n      undefined,\n      false,\n      ts.factory.createNamedExports(\n        names.map((name) => {\n          const { id, isType } = this.#map.get(name)!;\n          return ts.factory.createExportSpecifier(isType, id, ts.factory.createIdentifier(name));\n        }),\n      ),\n      undefined,\n    );\n  }\n}\n\nexport class NamespaceExportManager extends StatementRecordManager<ExportDeclaration> {\n  readonly #map = new Map<string, Identifier | null>();\n\n  get size(): number {\n    return this.#map.size;\n  }\n\n  addCombined(path: string, name: string, uniqueId?: Identifier): Identifier {\n    const id = uniqueId ?? createFullyUniqueIdentifier(name);\n    this.#map.set(path, id);\n    return id;\n  }\n\n  addSpread(path: string): void {\n    this.#map.set(path, null);\n  }\n\n  override clear(): void {\n    this.#map.clear();\n  }\n\n  getIdentifier(path: string): Identifier | null | undefined {\n    return this.#map.get(path);\n  }\n\n  identifiers(): IterableIterator<Identifier | null> {\n    return this.#map.values();\n  }\n\n  isCombined(path: string): boolean | undefined {\n    return this.#map.has(path) ? this.#map.get(path) !== null : undefined;\n  }\n\n  isSpread(path: string): boolean | undefined {\n    return this.#map.has(path) ? this.#map.get(path) === null : undefined;\n  }\n\n  paths(): IterableIterator<string> {\n    return this.#map.keys();\n  }\n\n  override *statementRecords(): IterableIterator<StatementRecord<ExportDeclaration>> {\n    for (const [path, id] of this.#map) {\n      yield [\n        path,\n        ts.factory.createExportDeclaration(\n          undefined,\n          false,\n          id !== null ? ts.factory.createNamespaceExport(id) : undefined,\n          ts.factory.createStringLiteral(path),\n        ),\n      ];\n    }\n  }\n}\n\nexport class DefaultExportManager implements CodeConvertable<ExportAssignment | undefined> {\n  #id?: Identifier;\n\n  get isEmpty(): boolean {\n    return !this.#id;\n  }\n\n  set(id: Identifier | string): Identifier {\n    this.#id = typeof id === 'string' ? ts.factory.createIdentifier(id) : id;\n    return this.#id;\n  }\n\n  toCode(): ExportAssignment | undefined {\n    return this.#id ? ts.factory.createExportAssignment(undefined, undefined, this.#id) : undefined;\n  }\n}\n\nexport default class ExportManager implements CodeConvertable<readonly Statement[]> {\n  readonly default: DefaultExportManager = new DefaultExportManager();\n  readonly named: NamedExportManager;\n  readonly namespace: NamespaceExportManager;\n\n  get size(): number {\n    return (this.default.isEmpty ? 0 : 1) + this.named.size + this.namespace.size;\n  }\n\n  constructor(collator: Intl.Collator) {\n    this.named = new NamedExportManager(collator);\n    this.namespace = new NamespaceExportManager(collator);\n  }\n\n  toCode(): readonly Statement[] {\n    const defaultStatement = this.default.toCode();\n    const namedStatement = this.named.toCode();\n    const namespaceStatements = this.namespace.toCode();\n\n    const result: Statement[] = [];\n\n    if (namedStatement) {\n      result.push(namedStatement);\n    }\n\n    result.push(...namespaceStatements);\n\n    if (defaultStatement) {\n      result.push(defaultStatement);\n    }\n\n    return result;\n  }\n}\n"],"version":3}