import { _update, BinderNode } from './BinderNode.js';
import { type FieldStrategy } from './Field.js';
import { type AbstractModel, type DetachedModelConstructor, type Value } from './Models.js';
import type { ClassStaticProperties } from './types.js';
import { type InterpolateMessageCallback, type Validator, type ValueError } from './Validation.js';
export type BinderConfiguration<T> = Readonly<{
    onChange?(oldValue?: T): void;
    onSubmit?(value: T): Promise<T | undefined | void>;
}>;
export type BinderRootConfiguration<T> = BinderConfiguration<T> & Readonly<{
    context?: unknown;
}>;
export declare class BinderRoot<M extends AbstractModel = AbstractModel> extends BinderNode<M> {
    #private;
    static interpolateMessageCallback?: InterpolateMessageCallback<any>;
    readonly ['constructor']: ClassStaticProperties<typeof BinderRoot<M>>;
    constructor(Model: DetachedModelConstructor<M>, config?: BinderRootConfiguration<Value<M>>);
    get defaultValue(): Value<M>;
    set defaultValue(newValue: Value<M>);
    get binder(): BinderRoot;
    get value(): Value<M>;
    set value(newValue: Value<M>);
    get submitting(): boolean;
    get validating(): boolean;
    read(value: Value<M> | null | undefined): void;
    reset(): void;
    clear(): void;
    submit(): Promise<Value<M> | undefined | void>;
    submitTo<V>(endpointMethod: (value: Value<M>) => Promise<V>): Promise<V>;
    requestValidation<NM extends AbstractModel>(model: NM, validator: Validator<Value<NM>>): Promise<ReadonlyArray<ValueError<Value<NM>>>>;
    getFieldStrategy<TField>(elm: HTMLElement, model?: AbstractModel<TField>): FieldStrategy;
    protected performValidation(): Promise<void> | void;
    protected completeValidation(): void;
    protected [_update](oldValue: Value<M>): void;
}
