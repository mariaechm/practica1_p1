var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _a, _b, _c, _d, _e, _f, _ObjectModel_properties, _ArrayModel_createItem, _ArrayModel_items, _g;
import isNumeric from 'validator/es/lib/isNumeric.js';
import { getBinderNode } from './BinderNode.js';
import { IsNumber } from './Validators.js';
export const _createEmptyItemValue = Symbol('createEmptyItemValue');
export const _parent = Symbol('parent');
export const _key = Symbol('key');
export const _fromString = Symbol('fromString');
export const _validators = Symbol('validators');
export const _meta = Symbol('meta');
export const _getPropertyModel = Symbol('getPropertyModel');
export const _enum = Symbol('enum');
export const _items = Symbol('items');
const _optional = Symbol('optional');
export function hasFromString(model) {
    return _fromString in model;
}
export const modelDetachedParent = { $value$: undefined };
export function createDetachedModel(type) {
    return new type(modelDetachedParent, '$value$', false);
}
export class AbstractModel {
    static createEmptyValue() {
        return undefined;
    }
    constructor(parent, key, optional, options) {
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _b, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _c, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _d, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _e, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this[_parent] = parent;
        this[_key] = key;
        this[_optional] = optional;
        this[_validators] = options?.validators ?? [];
        this[_meta] = options?.meta ?? {};
    }
    toString() {
        return String(this.valueOf());
    }
    valueOf() {
        const { value } = getBinderNode(this);
        if (value === undefined) {
            throw new TypeError('Value is undefined');
        }
        return value;
    }
}
_a = _parent, _b = _validators, _c = _meta, _d = _optional, _e = _key;
export class PrimitiveModel extends AbstractModel {
}
export class BooleanModel extends PrimitiveModel {
    [_fromString](str) {
        return ['true', '1', 'yes'].includes(str.toLowerCase());
    }
}
Object.defineProperty(BooleanModel, "createEmptyValue", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: Boolean
});
export class NumberModel extends PrimitiveModel {
    static createEmptyValue() {
        return NaN;
    }
    constructor(parent, key, optional, options) {
        const validators = [new IsNumber(optional), ...(options?.validators ?? [])];
        super(parent, key, optional, { ...options, validators });
    }
    [_fromString](str) {
        if (str === '') {
            return undefined;
        }
        return isNumeric(str) ? Number.parseFloat(str) : NaN;
    }
}
export class StringModel extends PrimitiveModel {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, _f, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: String
        });
    }
}
_f = _fromString;
Object.defineProperty(StringModel, "createEmptyValue", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: String
});
export function makeEnumEmptyValueCreator(type) {
    const { [_enum]: enumObject } = createDetachedModel(type);
    const defaultValue = Object.values(enumObject)[0];
    return () => defaultValue;
}
export class EnumModel extends AbstractModel {
    [_fromString](value) {
        return value in this[_enum] ? value : undefined;
    }
}
export function* getObjectModelOwnAndParentGetters(model) {
    for (let proto = Object.getPrototypeOf(model); proto !== ObjectModel.prototype; proto = Object.getPrototypeOf(proto)) {
        const descriptors = Object.getOwnPropertyDescriptors(proto);
        for (const [name, { get }] of Object.entries(descriptors)) {
            if (get) {
                yield [name, get];
            }
        }
    }
}
export function makeObjectEmptyValueCreator(type) {
    const model = createDetachedModel(type);
    return () => {
        const obj = {};
        for (const [key, getter] of getObjectModelOwnAndParentGetters(model)) {
            const propertyModel = getter.call(model);
            obj[key] = (propertyModel[_optional] ? undefined : propertyModel.constructor.createEmptyValue());
        }
        return obj;
    };
}
export class ObjectModel extends AbstractModel {
    constructor() {
        super(...arguments);
        _ObjectModel_properties.set(this, {});
    }
    [(_ObjectModel_properties = new WeakMap(), _getPropertyModel)](key, init) {
        if (!__classPrivateFieldGet(this, _ObjectModel_properties, "f")[key]) {
            __classPrivateFieldGet(this, _ObjectModel_properties, "f")[key] = init(this, key);
        }
        return __classPrivateFieldGet(this, _ObjectModel_properties, "f")[key];
    }
}
Object.defineProperty(ObjectModel, "createEmptyValue", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: makeObjectEmptyValueCreator(ObjectModel)
});
export class ArrayModel extends AbstractModel {
    static createEmptyValue() {
        return [];
    }
    constructor(parent, key, optional, createItem, options) {
        super(parent, key, optional, options);
        Object.defineProperty(this, _g, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        _ArrayModel_createItem.set(this, void 0);
        _ArrayModel_items.set(this, []);
        __classPrivateFieldSet(this, _ArrayModel_createItem, createItem, "f");
        this[_createEmptyItemValue] = createItem(this, 0).constructor.createEmptyValue;
    }
    *[(_ArrayModel_createItem = new WeakMap(), _ArrayModel_items = new WeakMap(), _g = _createEmptyItemValue, _items)]() {
        const values = getBinderNode(this).value ?? [];
        if (values.length !== __classPrivateFieldGet(this, _ArrayModel_items, "f").length) {
            __classPrivateFieldGet(this, _ArrayModel_items, "f").length = values.length;
        }
        for (let i = 0; i < values.length; i++) {
            let item = __classPrivateFieldGet(this, _ArrayModel_items, "f")[i];
            if (!item) {
                item = __classPrivateFieldGet(this, _ArrayModel_createItem, "f").call(this, this, i);
                __classPrivateFieldGet(this, _ArrayModel_items, "f")[i] = item;
            }
            yield item;
        }
    }
    *[Symbol.iterator]() {
        for (const item of this[_items]()) {
            yield getBinderNode(item);
        }
    }
}
export const m = {
    items(model) {
        return model[_items]();
    },
};
//# sourceMappingURL=Models.js.map