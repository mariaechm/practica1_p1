import isAfter from 'validator/es/lib/isAfter.js';
import isBefore from 'validator/es/lib/isBefore.js';
import isBoolean from 'validator/es/lib/isBoolean.js';
import isDecimal from 'validator/es/lib/isDecimal.js';
import isEmail from 'validator/es/lib/isEmail.js';
import isFloat from 'validator/es/lib/isFloat.js';
import isLength from 'validator/es/lib/isLength.js';
import matches from 'validator/es/lib/matches.js';
import toFloat from 'validator/es/lib/toFloat.js';
class AbstractValidator {
    constructor(attrs) {
        Object.defineProperty(this, "message", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'invalid'
        });
        Object.defineProperty(this, "impliesRequired", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        if (attrs?.message) {
            this.message = attrs.message;
        }
    }
}
export class Required extends AbstractValidator {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "impliesRequired", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Required'
        });
    }
    validate(value) {
        if (typeof value === 'string' || Array.isArray(value)) {
            return value.length > 0;
        }
        if (typeof value === 'number') {
            return Number.isFinite(value);
        }
        return value !== undefined;
    }
}
function _asValidatorAttributes(attrs) {
    return typeof attrs === 'object' ? attrs : {};
}
function _value(attrs) {
    return typeof attrs === 'object' ? attrs.value : attrs;
}
class NumberValidator extends AbstractValidator {
    validate(value) {
        const num = Number(value);
        return !isNaN(num) && isFinite(num);
    }
}
export class IsNumber extends NumberValidator {
    constructor(optional, attrs) {
        super({ message: 'must be a number', ...attrs });
        Object.defineProperty(this, "optional", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'IsNumber'
        });
        this.optional = optional;
    }
    validate(value) {
        return (this.optional && value == null) || super.validate(value);
    }
}
class ValueNumberValidator extends NumberValidator {
    constructor(attrs) {
        super(_asValidatorAttributes(attrs));
        Object.defineProperty(this, "value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        const val = _value(attrs);
        this.value = typeof val === 'string' ? parseFloat(val) : val;
    }
}
export class Email extends AbstractValidator {
    constructor(attrs) {
        super({ message: 'must be a well-formed email address', ...attrs });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Email'
        });
    }
    validate(value) {
        return !value || isEmail(value);
    }
}
export class Null extends AbstractValidator {
    constructor(attrs) {
        super({ message: 'must be null', ...attrs });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Null'
        });
    }
    validate(value) {
        return value == null;
    }
}
export class NotNull extends Required {
    constructor(attrs) {
        super({ message: 'must not be null', ...attrs });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'NotNull'
        });
    }
    validate(value) {
        return !new Null().validate(value);
    }
}
export class NotEmpty extends Required {
    constructor(attrs) {
        super({ message: 'must not be empty', ...attrs });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'NotEmpty'
        });
    }
    validate(value) {
        return (super.validate(value) && new NotNull().validate(value) && (value.length ?? 0) > 0);
    }
}
export class NotBlank extends Required {
    constructor(attrs) {
        super({ message: 'must not be blank', ...attrs });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'NotBlank'
        });
    }
    validate(value) {
        return super.validate(value) && new NotNull().validate(value) && String(value).trim().length > 0;
    }
}
export class AssertTrue extends AbstractValidator {
    constructor(attrs) {
        super({ message: 'must be true', ...attrs });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AssertTrue'
        });
    }
    validate(value) {
        return isBoolean(String(value)) && String(value) === 'true';
    }
}
export class AssertFalse extends AbstractValidator {
    constructor(attrs) {
        super({ message: 'must be false', ...attrs });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AssertFalse'
        });
    }
    validate(value) {
        return !new AssertTrue().validate(value);
    }
}
function _asValueNumberAttributes(attrs) {
    return typeof attrs === 'object' ? attrs : { value: attrs };
}
export class Min extends ValueNumberValidator {
    constructor(attrs) {
        super({
            message: `must be greater than or equal to ${_value(attrs)}`,
            ..._asValueNumberAttributes(attrs),
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Min'
        });
    }
    validate(value) {
        return super.validate(value) && isFloat(String(value), { min: this.value });
    }
}
export class Max extends ValueNumberValidator {
    constructor(attrs) {
        super({
            message: `must be less than or equal to ${_value(attrs)}`,
            ..._asValueNumberAttributes(attrs),
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Max'
        });
    }
    validate(value) {
        return super.validate(value) && isFloat(String(value), { max: this.value });
    }
}
function _inclusive(attrs) {
    return typeof attrs !== 'object' || attrs.inclusive !== false;
}
export class DecimalMin extends ValueNumberValidator {
    constructor(attrs) {
        super({
            message: `must be greater than ${_inclusive(attrs) ? 'or equal to ' : ''}${_value(attrs)}`,
            ..._asValueNumberAttributes(attrs),
        });
        Object.defineProperty(this, "inclusive", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'DecimalMin'
        });
        this.inclusive = _inclusive(attrs);
    }
    validate(value) {
        return super.validate(value) && isFloat(String(value), { [this.inclusive ? 'min' : 'gt']: this.value });
    }
}
export class DecimalMax extends ValueNumberValidator {
    constructor(attrs) {
        super({
            message: `must be less than ${_inclusive(attrs) ? 'or equal to ' : ''}${_value(attrs)}`,
            ..._asValueNumberAttributes(attrs),
        });
        Object.defineProperty(this, "inclusive", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'DecimalMax'
        });
        this.inclusive = _inclusive(attrs);
    }
    validate(value) {
        return super.validate(value) && isFloat(String(value), { [this.inclusive ? 'max' : 'lt']: this.value });
    }
}
export class Negative extends AbstractValidator {
    constructor(attrs) {
        super({ message: 'must be less than 0', ...attrs });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Negative'
        });
    }
    validate(value) {
        const fv = toFloat(String(value));
        return isNaN(fv) || fv < 0;
    }
}
export class NegativeOrZero extends AbstractValidator {
    constructor(attrs) {
        super({ message: 'must be less than or equal to 0', ...attrs });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'NegativeOrZero'
        });
    }
    validate(value) {
        return (toFloat(String(value)) || 0) <= 0;
    }
}
export class Positive extends AbstractValidator {
    constructor(attrs) {
        super({ message: 'must be greater than 0', ...attrs });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Positive'
        });
    }
    validate(value) {
        const fv = toFloat(String(value));
        return isNaN(fv) || fv > 0;
    }
}
export class PositiveOrZero extends AbstractValidator {
    constructor(attrs) {
        super({ message: 'must be greater than or equal to 0', ...attrs });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'PositiveOrZero'
        });
    }
    validate(value) {
        return (toFloat(String(value)) || 0) >= 0;
    }
}
function _min(attrs) {
    return attrs.min ?? 0;
}
function _max(attrs) {
    return attrs.max ?? Number.MAX_SAFE_INTEGER;
}
export class Size extends AbstractValidator {
    constructor(attrs = {}) {
        super({ message: `size must be between ${_min(attrs)} and ${_max(attrs)}`, ...attrs });
        Object.defineProperty(this, "min", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "max", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Size'
        });
        this.min = _min(attrs);
        this.max = _max(attrs);
        if (this.min > 0) {
            this.impliesRequired = true;
        }
    }
    validate(value) {
        if (this.min && this.min > 0 && !new Required().validate(value)) {
            return false;
        }
        return isLength(value, { min: this.min, max: this.max });
    }
}
export class Digits extends AbstractValidator {
    constructor(attrs) {
        super({
            message: `numeric value out of bounds (<${attrs.integer} digits>.<${attrs.fraction} digits> expected)`,
            ...attrs,
        });
        Object.defineProperty(this, "integer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fraction", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Digits'
        });
        this.integer = attrs.integer;
        this.fraction = attrs.fraction;
    }
    validate(value) {
        return (String(Math.floor(Math.abs(toFloat(String(value))))).length <= this.integer &&
            isDecimal(String(value), { decimal_digits: `0,${this.fraction}` }));
    }
}
export class Past extends AbstractValidator {
    constructor(attrs) {
        super({ message: 'must be a past date', ...attrs });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Past'
        });
    }
    validate(value) {
        return isBefore(String(value));
    }
}
export class Future extends AbstractValidator {
    constructor(attrs) {
        super({ message: 'must be a future date', ...attrs });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Future'
        });
    }
    validate(value) {
        return isAfter(String(value));
    }
}
function _regexp(attrs) {
    if (typeof attrs === 'string') {
        return new RegExp(attrs, 'u');
    }
    if (attrs instanceof RegExp) {
        return attrs;
    }
    if (typeof attrs.regexp === 'string') {
        return new RegExp(attrs.regexp, 'u');
    }
    return attrs.regexp;
}
export class Pattern extends AbstractValidator {
    constructor(attrs) {
        super({
            message: `must match the following regular expression: ${_regexp(attrs).toString()}`,
            ..._asValidatorAttributes(attrs),
        });
        Object.defineProperty(this, "regexp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Pattern'
        });
        this.regexp = _regexp(attrs);
    }
    validate(value) {
        return matches(value, this.regexp);
    }
}
export class ValidityStateValidator extends AbstractValidator {
    constructor() {
        super();
        Object.defineProperty(this, "message", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ''
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'ValidityStateValidator'
        });
    }
    validate() {
        return false;
    }
}
//# sourceMappingURL=Validators.js.map