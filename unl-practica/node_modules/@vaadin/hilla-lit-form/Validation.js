import { getBinderNode } from './BinderNode.js';
import { AbstractModel } from './Models.js';
import { IsNumber, Required, ValidityStateValidator } from './Validators.js';
export class ValidationError extends Error {
    constructor(errors) {
        super([
            'There are validation errors in the form.',
            ...errors.map((e) => {
                const property = e.property instanceof AbstractModel ? String(getBinderNode(e.property).value) : e.property;
                return `${property} - ${e.validator.constructor.name}${e.message ? `: ${e.message}` : ''}`;
            }),
        ].join('\n - '));
        Object.defineProperty(this, "errors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.errors = errors;
        this.name = this.constructor.name;
    }
}
export class ServerValidator {
    constructor(message) {
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'ServerValidator'
        });
        Object.defineProperty(this, "message", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "validate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => false
        });
        this.message = message;
    }
}
function setPropertyAbsolutePath(binderNodeName, result) {
    if (typeof result.property === 'string' && binderNodeName.length > 0) {
        result.property = `${binderNodeName}.${result.property}`;
    }
    return result;
}
export async function runValidator(model, validator, interpolateMessageCallback) {
    const binderNode = getBinderNode(model);
    const value = binderNode.value;
    const interpolateMessage = (message) => {
        if (!interpolateMessageCallback) {
            return message;
        }
        return interpolateMessageCallback(message, validator, binderNode);
    };
    if (!binderNode.required &&
        !new Required().validate(value) &&
        !(validator instanceof IsNumber) &&
        !(validator instanceof ValidityStateValidator)) {
        return [];
    }
    try {
        const result = await validator.validate(value, binderNode.binder);
        if (result === false) {
            return [
                {
                    message: interpolateMessage(validator.message),
                    property: binderNode.name,
                    validator,
                    value,
                },
            ];
        }
        if (result === true || (Array.isArray(result) && result.length === 0)) {
            return [];
        }
        if (Array.isArray(result)) {
            return result.map((result2) => ({
                message: interpolateMessage(validator.message),
                ...setPropertyAbsolutePath(binderNode.name, result2),
                validator,
                value,
            }));
        }
        return [
            {
                message: interpolateMessage(validator.message),
                ...setPropertyAbsolutePath(binderNode.name, result),
                validator,
                value,
            },
        ];
    }
    catch (error) {
        console.error(`${binderNode.name} - Validator ${validator.constructor.name} threw an error:`, error);
        return [{ message: 'Validator threw an error', property: binderNode.name, validator, value }];
    }
}
//# sourceMappingURL=Validation.js.map