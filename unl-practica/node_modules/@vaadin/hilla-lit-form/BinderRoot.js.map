{"version":3,"file":"BinderRoot.js","sourceRoot":"","sources":["src/BinderRoot.ts"],"names":[],"mappings":"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","sourcesContent":["import { EndpointValidationError, type ValidationErrorData } from '@vaadin/hilla-frontend/EndpointErrors.js';\nimport { _clearValidation, _setErrorsWithDescendants, _update, BinderNode, CHANGED } from './BinderNode.js';\nimport { type FieldElement, type FieldStrategy, getDefaultFieldStrategy } from './Field.js';\nimport {\n  _parent,\n  type AbstractModel,\n  createDetachedModel,\n  type DetachedModelConstructor,\n  type Value,\n} from './Models.js';\nimport type { ClassStaticProperties } from './types.js';\nimport {\n  type InterpolateMessageCallback,\n  runValidator,\n  ServerValidator,\n  ValidationError,\n  type Validator,\n  type ValueError,\n} from './Validation.js';\n\nexport type BinderConfiguration<T> = Readonly<{\n  onChange?(oldValue?: T): void;\n  onSubmit?(value: T): Promise<T | undefined | void>;\n}>;\n\nexport type BinderRootConfiguration<T> = BinderConfiguration<T> &\n  Readonly<{\n    context?: unknown;\n  }>;\n\n/**\n * A simplified Binder that does not require a context.\n * It can be used as root when there is no Element to use as context.\n *\n * @typeParam T - Type of the value that binds to a form\n * @typeParam M - Type of the model that describes the structure of the value\n */\nexport class BinderRoot<M extends AbstractModel = AbstractModel> extends BinderNode<M> {\n  static interpolateMessageCallback?: InterpolateMessageCallback<any>;\n\n  #defaultValue!: Value<M>; // Initialized in the `read()` method\n\n  #value!: Value<M>; // Initialized in the `read()` method\n\n  readonly #emptyValue: Value<M>;\n\n  #submitting = false;\n\n  #validating = false;\n\n  #validationRequest?: Promise<void>;\n\n  readonly #config?: BinderRootConfiguration<Value<M>>;\n\n  readonly #validations = new Map<AbstractModel, Map<Validator, Promise<readonly ValueError[]>>>();\n\n  readonly #context: unknown = this;\n\n  declare readonly ['constructor']: ClassStaticProperties<typeof BinderRoot<M>>;\n\n  /**\n   *\n   * @param Model - The constructor (the class reference) of the form model. The Binder instantiates the top-level model\n   * @param config - The options object, which can be used to config the onChange and onSubmit callbacks.\n   *\n   * ```\n   * binder = new BinderRoot(OrderModel);\n   * or\n   * binder = new BinderRoot(OrderModel, {onSubmit: async (order) => {endpoint.save(order)}});\n   * ```\n   */\n  constructor(Model: DetachedModelConstructor<M>, config?: BinderRootConfiguration<Value<M>>) {\n    super(createDetachedModel(Model));\n    // @ts-expect-error the model's parent is the binder\n    this.model[_parent] = this;\n    this.#context = config?.context ?? this;\n    this.#config = config;\n    // Initialize value instead of the parent.\n    this.initializeValue(true);\n    this.#emptyValue = this.value;\n  }\n\n  /**\n   * The initial value of the form, before any fields are edited by the user.\n   */\n  override get defaultValue(): Value<M> {\n    return this.#defaultValue;\n  }\n\n  override set defaultValue(newValue: Value<M>) {\n    this.#defaultValue = newValue;\n    this.dispatchEvent(CHANGED);\n  }\n\n  override get binder(): BinderRoot {\n    return this as BinderRoot;\n  }\n\n  /**\n   * The current value of the form.\n   */\n  override get value(): Value<M> {\n    return this.#value;\n  }\n\n  override set value(newValue: Value<M>) {\n    if (newValue === this.#value) {\n      return;\n    }\n\n    const oldValue = this.#value;\n    this.#value = newValue;\n    this[_update](oldValue);\n  }\n\n  /**\n   * Indicates the submitting status of the form.\n   * True if the form was submitted, but the submit promise is not resolved yet.\n   */\n  get submitting(): boolean {\n    return this.#submitting;\n  }\n\n  /**\n   * Indicates the validating status of the form.\n   * True when there is an ongoing validation.\n   */\n  get validating(): boolean {\n    return this.#validating;\n  }\n\n  /**\n   * Read the given value into the form and clear validation errors. Clears the form if the value is undefined.\n   *\n   * @param value - The value to read, or undefined to clear.\n   */\n  read(value: Value<M> | null | undefined): void {\n    if (value === undefined || value === null) {\n      this.clear();\n      return;\n    }\n    this.defaultValue = value;\n    if (\n      // Skip when no value is set yet (e.g., invoked from constructor)\n      this.value &&\n      // Clear validation state, then proceed if update is needed\n      this[_clearValidation]() &&\n      // When value is dirty, another update is coming from invoking the value\n      // setter below, so we skip this one to prevent duplicate updates\n      this.value === value\n    ) {\n      this[_update](this.value);\n    }\n\n    this.value = this.defaultValue;\n  }\n\n  /**\n   * Reset the form to the previous value\n   */\n  reset(): void {\n    this.read(this.#defaultValue);\n  }\n\n  /**\n   * Sets the form to empty value, as defined in the Model.\n   */\n  clear(): void {\n    this.read(this.#emptyValue);\n  }\n\n  /**\n   * Submit the current form value to a predefined\n   * onSubmit callback.\n   *\n   * It's a no-op if the onSubmit callback is undefined.\n   */\n  async submit(): Promise<Value<M> | undefined | void> {\n    const onSubmit = this.#config?.onSubmit;\n    if (onSubmit) {\n      return this.submitTo(onSubmit);\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Submit the current form value to callback\n   *\n   * @param endpointMethod - the callback function\n   */\n  async submitTo<V>(endpointMethod: (value: Value<M>) => Promise<V>): Promise<V> {\n    const errors = await this.validate();\n    if (errors.length) {\n      throw new ValidationError(errors);\n    }\n\n    this.#submitting = true;\n    this[_update](this.value);\n    this.dispatchEvent(CHANGED);\n    try {\n      return await endpointMethod.call(this.#context, this.value);\n    } catch (error: unknown) {\n      if (error instanceof EndpointValidationError && error.validationErrorData.length) {\n        const valueErrors: Array<ValueError<any>> = [];\n        error.validationErrorData.forEach((data: ValidationErrorData) => {\n          const res =\n            /Object of type '(.+)' has invalid property '(.+)' with value '(.+)', validation error: '(.+)'/u.exec(\n              data.message,\n            );\n          const [property, value, message] = res ? res.splice(2) : [data.parameterName ?? '', undefined, data.message];\n          valueErrors.push({\n            message,\n            // Convert property from bracket notation to dot notation\n            // Example: 'orders[0].description' becomes 'orders.0.description'\n            property: property.replace(/\\[(\\d+)\\]/gu, '.$1'),\n            validator: new ServerValidator(message),\n            value,\n            validatorMessage: data.validatorMessage,\n          });\n        });\n        this[_setErrorsWithDescendants](valueErrors);\n        throw new ValidationError(valueErrors);\n      }\n\n      throw error;\n    } finally {\n      this.#submitting = false;\n      this.defaultValue = this.value;\n      this[_update](this.value);\n    }\n  }\n\n  async requestValidation<NM extends AbstractModel>(\n    model: NM,\n    validator: Validator<Value<NM>>,\n  ): Promise<ReadonlyArray<ValueError<Value<NM>>>> {\n    let modelValidations: Map<Validator<Value<NM>>, Promise<ReadonlyArray<ValueError<Value<NM>>>>>;\n\n    if (this.#validations.has(model)) {\n      modelValidations = this.#validations.get(model) as Map<\n        Validator<Value<NM>>,\n        Promise<ReadonlyArray<ValueError<Value<NM>>>>\n      >;\n    } else {\n      modelValidations = new Map();\n      this.#validations.set(model, modelValidations);\n    }\n\n    await this.performValidation();\n\n    if (modelValidations.has(validator)) {\n      return modelValidations.get(validator)!;\n    }\n\n    const promise = runValidator(model, validator, this.constructor.interpolateMessageCallback);\n    modelValidations.set(validator, promise);\n    const valueErrors = await promise;\n\n    modelValidations.delete(validator);\n    if (modelValidations.size === 0) {\n      this.#validations.delete(model);\n    }\n    if (this.#validations.size === 0) {\n      this.completeValidation();\n    }\n\n    return valueErrors;\n  }\n\n  /**\n   * Determines and returns the field directive strategy for the bound element.\n   * Override to customise the binding strategy for a component.\n   * The Binder extends BinderNode, see the inherited properties and methods below.\n   *\n   * @param elm - the bound element\n   * @param model - the bound model\n   */\n  // eslint ignored to allow overriding\n  // eslint-disable-next-line @typescript-eslint/class-methods-use-this\n  getFieldStrategy<TField>(elm: HTMLElement, model?: AbstractModel<TField>): FieldStrategy {\n    return getDefaultFieldStrategy(elm as FieldElement, model);\n  }\n\n  protected performValidation(): Promise<void> | void {\n    if (!this.#validationRequest) {\n      this.#validating = true;\n      this.dispatchEvent(CHANGED);\n      this.#validationRequest = Promise.resolve().then(() => {\n        this.#validationRequest = undefined;\n      });\n    }\n    return this.#validationRequest;\n  }\n\n  protected completeValidation(): void {\n    this.#validating = false;\n    this.dispatchEvent(CHANGED);\n  }\n\n  protected override [_update](oldValue: Value<M>): void {\n    this.#config?.onChange?.call(this.#context, oldValue);\n    this.dispatchEvent(CHANGED);\n  }\n}\n"]}