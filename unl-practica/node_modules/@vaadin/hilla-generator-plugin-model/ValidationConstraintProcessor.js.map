{"version":3,"file":"ValidationConstraintProcessor.js","sourceRoot":"","sources":["src/ValidationConstraintProcessor.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,sCAAsC,CAAC;AAC3E,OAAO,EAAE,EAAE,EAMV,MAAM,YAAY,CAAC;AAKpB,MAAM,UAAU,wBAAwB,CAAC,MAAc;IACrD,OAAO,CACL,0BAA0B,IAAI,MAAM;QACnC,MAAsC,CAAC,0BAA0B,CAAC,CAAC,MAAM,GAAG,CAAC,CAC/E,CAAC;AACJ,CAAC;AASD,SAAS,QAAQ,CAAuB,CAAC,SAAS,CAAuB;IACvE,OAAQ,SAA+B,CAAC,eAAe,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,WAAgB,CAAC;AAC3F,CAAC;AAED,MAAM,oBAAoB,GAAG,SAAS,CAAC;AAEvC,MAAM,OAAO,6BAA6B;IAC/B,SAAS,CAA+B;IAEjD,YAAY,QAAsC;QAChD,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;IAC5B,CAAC;IAED,OAAO,CAAC,UAAgC;QACtC,OAAO,EAAE,CAAC,OAAO,CAAC,mBAAmB,CACnC,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,UAAU,CAAC,EACrC,SAAS,EACT,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,6BAA6B,CAAC,kBAAkB,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CACvG,CAAC;IACJ,CAAC;IAED,MAAM,CAAC,kBAAkB,CAAC,UAAmC;QAC3D,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QACtC,MAAM,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC;QAE1G,OAAO,QAAQ,CAAC,GAAG,oBAAoB,IAAI,GAAG,EAAE,EAAE,QAAQ,EAAE;YAC1D,SAAS,CAAC,CAAC,IAAI,EAAE,EAAE,CACjB,EAAE,CAAC,oBAAoB,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC;gBAC5D,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,wBAAwB,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,WAAW,CAAC;gBACvE,CAAC,CAAC,IAAI,CACT;SACF,CAAC,CAAC;IACL,CAAC;CACF","sourcesContent":["import type { NonComposedRegularSchema, Schema } from '@vaadin/hilla-generator-core/Schema.js';\nimport { template, transform } from '@vaadin/hilla-generator-utils/ast.js';\nimport ts, {\n  type Expression,\n  type Identifier,\n  type NewExpression,\n  type Statement,\n  type VariableStatement,\n} from 'typescript';\n\nexport type ValidationConstrainedSchema = NonComposedRegularSchema &\n  Readonly<{ 'x-validation-constraints': readonly ValidationConstraint[] }>;\n\nexport function hasValidationConstraints(schema: Schema): schema is ValidationConstrainedSchema {\n  return (\n    'x-validation-constraints' in schema &&\n    (schema as ValidationConstrainedSchema)['x-validation-constraints'].length > 0\n  );\n}\n\nexport interface ValidationConstraint {\n  simpleName: string;\n  attributes?: Record<string, unknown>;\n}\n\nexport type ValidationConstraintImporter = (name: string) => Identifier;\n\nfunction selector<T extends Expression>([statement]: readonly Statement[]): T {\n  return (statement as VariableStatement).declarationList.declarations[0].initializer as T;\n}\n\nconst variableStatementVar = 'const a';\n\nexport class ValidationConstraintProcessor {\n  readonly #importer: ValidationConstraintImporter;\n\n  constructor(importer: ValidationConstraintImporter) {\n    this.#importer = importer;\n  }\n\n  process(constraint: ValidationConstraint): NewExpression {\n    return ts.factory.createNewExpression(\n      this.#importer(constraint.simpleName),\n      undefined,\n      constraint.attributes ? [ValidationConstraintProcessor.#processAttributes(constraint.attributes)] : [],\n    );\n  }\n\n  static #processAttributes(attributes: Record<string, unknown>): Expression {\n    const names = Object.keys(attributes);\n    const tpl = JSON.stringify(names.includes('value') && names.length === 1 ? attributes.value : attributes);\n\n    return template(`${variableStatementVar}=${tpl}`, selector, [\n      transform((node) =>\n        ts.isPropertyAssignment(node) && ts.isStringLiteral(node.name)\n          ? ts.factory.createPropertyAssignment(node.name.text, node.initializer)\n          : node,\n      ),\n    ]);\n  }\n}\n"]}