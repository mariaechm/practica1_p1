{"mappings":"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","names":["#logger","#outputDir","outputDir: string","logger: LoggerFactory","generatedFiles: string[]","filesToDelete: Set<string>","filenames: string[]","files: readonly File[]","path: string","modulePath: string","module: PluginConstructorModule","ctr: PluginConstructor","filename: string","content: string"],"sources":["/opt/agent/work/1af72d8adc613024/hilla/packages/ts/generator-cli/src/GeneratorIO.ts"],"sourcesContent":["import { constants } from 'node:fs';\nimport { access, mkdir, readFile, rm, writeFile } from 'node:fs/promises';\nimport { createRequire } from 'node:module';\nimport { dirname, isAbsolute, join, resolve } from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport Plugin, { type PluginConstructor } from '@vaadin/hilla-generator-core/Plugin.js';\nimport type LoggerFactory from '@vaadin/hilla-generator-utils/LoggerFactory.js';\nimport GeneratorIOException from './GeneratorIOException.js';\n\nconst require = createRequire(import.meta.url);\n\ntype PluginConstructorModule = Readonly<{\n  default: PluginConstructor;\n}>;\n\nexport default class GeneratorIO {\n  static readonly INDEX_FILENAME = 'generated-file-list.txt';\n  declare ['constructor']: typeof GeneratorIO;\n  readonly cwd: string;\n  readonly #logger: LoggerFactory;\n  readonly #outputDir: string;\n\n  constructor(outputDir: string, logger: LoggerFactory) {\n    this.cwd = process.cwd();\n    this.#outputDir = isAbsolute(outputDir) ? outputDir : resolve(this.cwd, outputDir);\n    this.#logger = logger;\n\n    logger.global.debug(`Output directory: ${this.#outputDir}`);\n  }\n\n  /**\n   * Gets the list of files generated the last time. The info is found in {@link INDEX_FILENAME}.\n   * @returns a list of files that have been generated by us\n   */\n  async getGeneratedFiles(): Promise<Set<string>> {\n    const files = new Set<string>();\n    try {\n      const indexFileContents = await this.read(this.resolveGeneratedFile(this.constructor.INDEX_FILENAME));\n      indexFileContents\n        .split('\\n')\n        .filter((n) => n.length)\n        .forEach((fileName) => files.add(fileName));\n    } catch (e) {\n      // non-existing file is OK, all other errors must be rethrown\n      if (!(e instanceof Error && 'code' in e && e.code === 'ENOENT')) {\n        throw e;\n      }\n    }\n    return files;\n  }\n\n  /**\n   * Cleans the output directory by keeping the generated files and deleting the rest of the given files.\n   *\n   * @returns a set containing deleted filenames\n   */\n  async cleanOutputDir(generatedFiles: string[], filesToDelete: Set<string>): Promise<Set<string>> {\n    this.#logger.global.debug(`Cleaning ${this.#outputDir}`);\n    await mkdir(this.#outputDir, { recursive: true });\n\n    generatedFiles.forEach((filename) => {\n      this.#logger.global.debug(`File ${filename} was re-written, should not delete it`);\n      filesToDelete.delete(filename);\n    });\n\n    const deletedFiles = new Set(\n      await Promise.all(\n        [...filesToDelete].map(async (filename) => {\n          const resolved = this.resolveGeneratedFile(filename);\n          if (await GeneratorIO.exists(resolved)) {\n            this.#logger.global.debug(`Deleting file ${filename}.`);\n            await rm(resolved);\n          }\n          return filename;\n        }),\n      ),\n    );\n\n    return deletedFiles;\n  }\n\n  async createFileIndex(filenames: string[]): Promise<void> {\n    await this.write(this.constructor.INDEX_FILENAME, filenames.join('\\n'));\n  }\n\n  async writeGeneratedFiles(files: readonly File[]): Promise<string[]> {\n    await this.createFileIndex(files.map((file) => file.name));\n    this.#logger.global.debug(`created index`);\n\n    return Promise.all(\n      files.map(async (file) => {\n        const newFileContent = await file.text();\n        let oldFileContent;\n        try {\n          oldFileContent = await this.read(this.resolveGeneratedFile(file.name));\n        } catch (_e) {}\n\n        if (newFileContent !== oldFileContent) {\n          this.#logger.global.debug(`writing file ${file.name}`);\n          await this.write(file.name, await file.text());\n        } else {\n          this.#logger.global.debug(`File ${file.name} stayed the same`);\n        }\n        return file.name;\n      }),\n    );\n  }\n\n  /**\n   * Checks that a file exists (is visible)\n   * @param path - the file path to check\n   */\n  // eslint-disable-next-line class-methods-use-this\n  static async exists(path: string): Promise<boolean> {\n    try {\n      await access(path, constants.F_OK);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async loadPlugin(modulePath: string): Promise<PluginConstructor> {\n    this.#logger.global.debug(`Loading plugin: ${modulePath}`);\n    const module: PluginConstructorModule = await import(pathToFileURL(require.resolve(modulePath)).toString());\n    const ctr: PluginConstructor = module.default;\n\n    if (!Object.prototype.isPrototypeOf.call(Plugin, ctr)) {\n      throw new GeneratorIOException(`Plugin '${modulePath}' is not an instance of a Plugin class`);\n    }\n\n    return ctr;\n  }\n\n  resolveGeneratedFile(filename: string): string {\n    return resolve(this.#outputDir, filename);\n  }\n\n  async read(path: string): Promise<string> {\n    this.#logger.global.debug(`Reading file: ${path}`);\n    return readFile(path, 'utf8');\n  }\n\n  async write(filename: string, content: string): Promise<void> {\n    const filePath = join(this.#outputDir, filename);\n    this.#logger.global.debug(`Writing file ${filePath}.`);\n    const dir = dirname(filePath);\n    await mkdir(dir, { recursive: true });\n    return writeFile(filePath, content, 'utf-8');\n  }\n}\n"],"version":3}