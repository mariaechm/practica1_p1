import { signal } from "@vaadin/hilla-react-signals";
export const viewsSignal = signal(window.Vaadin?.views);
function isExcluded(value) {
	return !!value.menu?.exclude;
}
function hasVariablePathSegment(path) {
	return path.split("/").some((segment) => segment.startsWith(":"));
}
/**
* Creates menu items from the views provided by the server. The views are sorted according to the
* {@link ViewConfig.menu.order}, filtered out if they are explicitly excluded via {@link ViewConfig.menu.exclude}.
* Note that views with no order are put below views with an order. Ties are resolved based on the path string
* comparison.
*
* @returns A list of menu items.
*/
export function createMenuItems() {
	((feature, vaadinObj = window.Vaadin ??= {}) => {
		vaadinObj.registrations ??= [];
		vaadinObj.registrations.push({
			is: feature ? `@vaadin/hilla-file-router/${feature}` : "@vaadin/hilla-file-router",
			version: "24.7.4"
		});
	})("createMenuItems", window.Vaadin);
	const collator = new Intl.Collator("en-US");
	if (!viewsSignal.value) {
		return [];
	}
	const views = Object.entries(viewsSignal.value);
	return views.filter(([path, value]) => !isExcluded(value) && !hasVariablePathSegment(path)).map(([path, config]) => ({
		to: path,
		icon: config.menu?.icon,
		title: config.menu?.title ?? config.title,
		order: config.menu?.order
	})).sort((menuA, menuB) => {
		const ordersDiff = (menuA.order ?? Number.MAX_VALUE) - (menuB.order ?? Number.MAX_VALUE);
		return ordersDiff !== 0 ? ordersDiff : collator.compare(menuA.to, menuB.to);
	});
}
if (import.meta.hot) {
	import.meta.hot.on("fs-route-update", () => {
		fetch("?v-r=routeinfo").then(async (resp) => resp.json()).then((json) => {
			viewsSignal.value = json;
		}).catch((e) => {
			console.error("Failed to fetch route info", e);
		});
	});
}
//# sourceMappingURL=./createMenuItems.js.map