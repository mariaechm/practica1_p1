{"mappings":"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","names":["module: Module","route: T","route: RouteObject","flag: T","#modifiers","routes: RouteList","routes: readonly AgnosticRoute[]","component: ComponentType","config?: ViewConfig","fallbackRoutes: RouteList","layoutComponent: ComponentType","redirectPath?: string","routes: readonly T[] | undefined","callback: RouteTransformer<T | undefined>","final: Array<RouteObject | undefined>","options?: RouterBuildOptions","#withLayoutSkipping"],"sources":["/opt/agent/work/1af72d8adc613024/hilla/packages/ts/file-router/src/runtime/RouterConfigurationBuilder.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/consistent-type-assertions */\nimport { protectRoute } from '@vaadin/hilla-react-auth';\nimport { type ComponentType, createElement } from 'react';\nimport { createBrowserRouter, type IndexRouteObject, type NonIndexRouteObject, type RouteObject } from 'react-router';\nimport { convertComponentNameToTitle } from '../shared/convertComponentNameToTitle.js';\nimport { transformTree } from '../shared/transformTree.js';\nimport type {\n  AgnosticRoute,\n  Module,\n  RouteModule,\n  RouterBuildOptions,\n  RouterConfiguration,\n  ViewConfig,\n} from '../types.js';\n\ninterface RouteBase {\n  path?: string;\n  children?: readonly this[];\n}\n\nfunction isReactRouteModule(module: Module): module is RouteModule<ComponentType> {\n  return (\n    ('default' in module && typeof module.default === 'function') ||\n    ('config' in module && typeof module.config === 'object')\n  );\n}\n\nexport type RouteList = readonly RouteObject[];\nexport type WritableRouteList = RouteObject[];\n\nexport type RouteTransformerOptions<T> = Readonly<{\n  children?: RouteList;\n  original?: RouteObject;\n  overriding?: T;\n  dupe: boolean;\n}>;\n\nexport type RouteTransformer<T> = (opts: RouteTransformerOptions<T>) => RouteObject | undefined;\n\ntype RoutesModifier = (routes: RouteList | undefined) => RouteList | undefined;\n\nfunction createRouteKey<T extends RouteBase>(route: T): string {\n  return `${route.path ?? ''}-${route.children ? 'n' : 'i'}`;\n}\n\nenum RouteHandleFlags {\n  FLOW_LAYOUT = 'flowLayout',\n  IGNORE_FALLBACK = 'ignoreFallback',\n  SKIP_LAYOUTS = 'skipLayouts',\n}\n\nfunction getRouteHandleFlag<T extends RouteHandleFlags>(route: RouteObject, flag: T): boolean | undefined {\n  if (typeof route.handle === 'object' && flag in route.handle) {\n    return (route.handle as Record<T, boolean>)[flag];\n  }\n\n  return undefined;\n}\n\n/**\n * A builder for creating a Vaadin-specific router for React with\n * authentication and server routes support.\n */\nexport class RouterConfigurationBuilder {\n  readonly #modifiers: RoutesModifier[] = [];\n\n  /**\n   * Adds the given routes to the current list of routes. All the routes are\n   * deeply merged to preserve the path uniqueness.\n   *\n   * @param routes - A list of routes to add to the current list.\n   */\n  withReactRoutes(routes: RouteList): this {\n    return this.update(routes);\n  }\n\n  /**\n   * Adds the given file routes to the current list of routes. All the routes\n   * are transformed to React RouterObjects and deeply merged to preserve the\n   * path uniqueness.\n   *\n   * @param routes - A list of routes to add to the current list.\n   */\n  withFileRoutes(routes: readonly AgnosticRoute[]): this {\n    return this.update(routes, ({ original, overriding: added, children }) => {\n      if (added) {\n        const { module, path, flowLayout } = added;\n        if (module && !isReactRouteModule(module)) {\n          throw new Error(\n            `The module for the \"${path}\" section doesn't have the React component exported by default or a ViewConfig object exported as \"config\"`,\n          );\n        }\n\n        const element = module?.default ? createElement(module.default) : undefined;\n        const handle = {\n          ...module?.config,\n          title: module?.config?.title ?? convertComponentNameToTitle(module?.default),\n          flowLayout: module?.config?.flowLayout ?? flowLayout,\n        };\n\n        if (path === '' && !children) {\n          return {\n            ...original,\n            element,\n            handle,\n            index: true,\n          } as IndexRouteObject;\n        }\n\n        return {\n          ...original,\n          path: module?.config?.route ?? path,\n          element,\n          children,\n          handle,\n        } as NonIndexRouteObject;\n      }\n\n      return original;\n    });\n  }\n\n  /**\n   * Adds the given server route element to each branch of the current list of\n   * routes.\n   *\n   * @param component - The React component to add to each branch of the\n   * current list of routes.\n   * @param config - An optional configuration that will be applied to\n   * each fallback component.\n   */\n  withFallback(component: ComponentType, config?: ViewConfig): this {\n    this.withLayout(component);\n\n    // Fallback adds two routes, so that the index (empty path) has a fallback too\n    const fallbackRoutes: RouteList = [\n      { path: '*', element: createElement(component), handle: config },\n      { index: true, element: createElement(component), handle: config },\n    ];\n\n    this.update(fallbackRoutes, ({ original, overriding: added, children, dupe }) => {\n      if (original && !getRouteHandleFlag(original, RouteHandleFlags.IGNORE_FALLBACK) && !dupe) {\n        if (!children) {\n          return original;\n        }\n\n        const _fallback = [...fallbackRoutes];\n\n        if (children.some(({ path }) => path === '*')) {\n          _fallback.shift();\n        }\n\n        if (children.some(({ index: i, path }) => i ?? path?.includes('?'))) {\n          _fallback.pop();\n        }\n\n        return {\n          ...original,\n          children: [...children, ..._fallback],\n        } as RouteObject;\n      }\n\n      return added!;\n    });\n\n    return this;\n  }\n\n  /**\n   * Adds the layoutComponent as the parent layout to views with the flowLayouts ViewConfiguration set.\n   *\n   * @param layoutComponent - layout component to use, usually Flow\n   */\n  withLayout(layoutComponent: ComponentType): this {\n    this.#modifiers.push((originalRoutes) => {\n      if (!originalRoutes) {\n        return originalRoutes;\n      }\n\n      type Accumulator<T extends RouteList> = Readonly<{\n        server: T;\n        client: T;\n        ambivalent: T;\n      }>;\n\n      const result = transformTree<RouteList, Accumulator<RouteList>>(originalRoutes, null, (routes, next) =>\n        // Split a single routes list onto three separate lists:\n        // - A list of server routes\n        // - A list of client routes\n        // - A list of routes which will be moved to either server or client\n        // list. It depends on the parent route.\n        routes.reduce<Accumulator<WritableRouteList>>(\n          (lists, route) => {\n            const { server, client, ambivalent } = next(route.children ?? []);\n\n            const flag = getRouteHandleFlag(route, RouteHandleFlags.FLOW_LAYOUT);\n\n            // If the route has `flowLayout` flag explicitly enabled, it goes to\n            // the server list. The children are also affected by the flag\n            // unless they have it explicitly disabled.\n            if (flag === true) {\n              lists.server.push({\n                ...route,\n                children: route.children ? [...server, ...ambivalent] : undefined,\n              } as RouteObject);\n            } else if (server.length > 0) {\n              // Even if the route doesn't have the flag, it goes to the server\n              // list if any of the children has the flag enabled.\n              lists.server.push({\n                ...route,\n                children: route.children ? server : undefined,\n              } as RouteObject);\n            }\n\n            // If the route has `flowLayout` flag explicitly disabled, it goes\n            // to the client list. The route children are not affected by the\n            // flag.\n            if (flag === false || client.length > 0) {\n              lists.client.push({\n                ...route,\n                children: route.children ? client : undefined,\n              } as RouteObject);\n            }\n\n            // The route without the flag go to the `default` list. Then it will\n            // be moved to either server or client list based on the parent\n            // route.\n            if (\n              flag === undefined &&\n              (lists.server.every(({ path }) => path !== route.path) || ambivalent.length > 0)\n            ) {\n              lists.ambivalent.push({\n                ...route,\n                children: route.children ? ambivalent : undefined,\n              } as RouteObject);\n            }\n\n            return lists;\n          },\n          { server: [], client: [], ambivalent: [] },\n        ),\n      );\n\n      return [\n        ...(result.server.length\n          ? [\n              // The server routes are wrapped with the route that has a layout\n              // element. It also has the `IGNORE_FALLBACK` flag to remove the\n              // fallback route from reach.\n              {\n                element: createElement(layoutComponent),\n                children: result.server as RouteObject[],\n                handle: {\n                  [RouteHandleFlags.IGNORE_FALLBACK]: true,\n                },\n              },\n            ]\n          : []),\n        // The client routes are preserved without wrapping.\n        ...result.client,\n        // The ambivalent routes are considered as client routes.\n        ...result.ambivalent,\n      ];\n    });\n\n    return this;\n  }\n\n  /**\n   * Protects all the routes that require authentication. For more details see\n   * {@link @vaadin/hilla-react-auth#protectRoutes} function.\n   *\n   * @param redirectPath - the path to redirect to if the route is protected\n   * and the user is not authenticated.\n   */\n  protect(redirectPath?: string): this {\n    this.update(undefined, ({ original: route, children }) => {\n      const finalRoute = protectRoute(route!, redirectPath);\n      finalRoute.children = children as RouteObject[] | undefined;\n      return finalRoute;\n    });\n\n    return this;\n  }\n\n  /**\n   * Deeply updates the current list of routes with the given routes merging\n   * them in process.\n   *\n   * @param routes - A list of routes to merge with the current list.\n   * @param callback - A callback to transform the routes during the merge.\n   */\n  update(routes: undefined, callback: RouteTransformer<undefined>): this;\n  update<T extends RouteBase>(routes: readonly T[], callback?: RouteTransformer<T>): this;\n  update<T extends RouteBase>(\n    routes: readonly T[] | undefined,\n    callback: RouteTransformer<T | undefined> = ({ original, overriding, children }) =>\n      ({\n        ...original,\n        ...overriding,\n        children,\n      }) as RouteObject,\n  ): this {\n    this.#modifiers.push((existingRoutes) =>\n      // Going through the existing and added list of routes.\n      transformTree<readonly [RouteList | undefined, readonly T[] | undefined], RouteList | undefined>(\n        [existingRoutes, routes],\n        null,\n        ([original, added], next) => {\n          if (original && added) {\n            // If we have both original and added routes, we have to merge them.\n            const final: Array<RouteObject | undefined> = [];\n            const pathKeys = new Set([...original.map(createRouteKey), ...added.map(createRouteKey)]);\n\n            for (const pathKey of pathKeys) {\n              // We can have multiple routes with the same path, so we have to\n              // consider all of them.\n              const originalRoutes = original.filter((r) => createRouteKey(r) === pathKey);\n              // We can have only one route with the same path in the added list.\n              const addedRoutes = added.filter((r) => createRouteKey(r) === pathKey);\n\n              if (addedRoutes.length > 1) {\n                throw new Error('Adding multiple routes with the same path is not allowed');\n              }\n\n              const addedRoute = addedRoutes[0] as T | undefined;\n\n              if (originalRoutes.length > 0 && addedRoute) {\n                // In case we have both original and added routes, we run\n                // the callback for each original route in pair with the added\n                // route. To make the difference, we flag all the routes except\n                // the last one as `dupe`.\n                //\n                // Why the last one is not `dupe`? According to the\n                // `react-router` logic, the last route is the fallback for all\n                // routes with the same path. So, if we apply callback to it,\n                // we implicitly apply it to all other routes with the same\n                // path.\n                //\n                // In case this logic doesn't work, the user can apply the\n                // callback without considering the `dupe` flag.\n                for (let i = 0; i < originalRoutes.length; i++) {\n                  final.push(\n                    callback({\n                      original: originalRoutes[i],\n                      overriding: addedRoute,\n                      children: next([originalRoutes[i].children, addedRoute.children]),\n                      dupe: i < originalRoutes.length - 1,\n                    }) ?? originalRoutes[i],\n                  );\n                }\n              } else if (originalRoutes.length > 0) {\n                // In case we don't have the added route with the path being\n                // processed, we run the callback for each original route.\n                for (let i = 0; i < originalRoutes.length; i++) {\n                  final.push(\n                    callback({\n                      original: originalRoutes[i],\n                      children: next([originalRoutes[i].children, undefined]),\n                      dupe: i < originalRoutes.length - 1,\n                    }) ?? originalRoutes[i],\n                  );\n                }\n              } else {\n                // In case we don't have the original route with the path being\n                // processed, we run the callback for only the added route.\n                const result = callback({\n                  overriding: addedRoute,\n                  children: next([undefined, addedRoute!.children]),\n                  dupe: false,\n                });\n\n                if (result) {\n                  final.push(result);\n                }\n              }\n            }\n\n            return final.filter((r) => r != null);\n          } else if (original) {\n            // If we have only original routes, we run the callback for each\n            // original route.\n            return original\n              .map((route) =>\n                callback({\n                  original: route,\n                  children: next([route.children, undefined]),\n                  dupe: false,\n                }),\n              )\n              .filter((r) => r != null);\n          } else if (added) {\n            // If we have only added routes, we run the callback for each added\n            // route.\n            return added\n              .map((route) =>\n                callback({\n                  overriding: route,\n                  children: next([undefined, route.children]),\n                  dupe: false,\n                }),\n              )\n              .filter((r) => r != null);\n          }\n\n          return undefined;\n        },\n      ),\n    );\n    return this;\n  }\n\n  /**\n   * Builds the router with the current list of routes.\n   */\n  build(options?: RouterBuildOptions): RouterConfiguration {\n    this.#withLayoutSkipping();\n    const routes = this.#modifiers.reduce<RouteList | undefined>((acc, mod) => mod(acc) ?? acc, undefined) ?? [];\n\n    return {\n      routes,\n      router: createBrowserRouter([...routes], { basename: new URL(document.baseURI).pathname, ...options }),\n    };\n  }\n\n  #withLayoutSkipping(): this {\n    this.#modifiers.push((originalRoutes) => {\n      if (!originalRoutes) {\n        return originalRoutes;\n      }\n\n      type Accumulator<T extends RouteList> = Readonly<{\n        skipped: T;\n        regular: T;\n      }>;\n\n      const result = transformTree<RouteList, Accumulator<RouteList>>(originalRoutes, null, (routes, next) =>\n        // Split a single routes list onto two separate lists.\n        routes.reduce<Accumulator<WritableRouteList>>(\n          (lists, route) => {\n            // If the route has `skipLayout` flag, it goes to the `skipped` list.\n            if (getRouteHandleFlag(route, RouteHandleFlags.SKIP_LAYOUTS)) {\n              lists.skipped.push(route);\n              return lists;\n            }\n\n            // If the route is leaf, it goes to the `regular` list.\n            if (!route.children?.length) {\n              lists.regular.push(route);\n              return lists;\n            }\n\n            // As of children, we have to split them into two lists as well.\n            const { skipped, regular } = next(route.children ?? []);\n\n            // If we have `skipped` list of children, we have to remove the\n            // `element` property of the router to prevent the layout from\n            // rendering. Then, we add the current route to the `skipped` list.\n            if (skipped.length > 0) {\n              const { element, ...rest } = route;\n\n              lists.skipped.push({\n                ...rest,\n                children: skipped,\n              } as RouteObject);\n            }\n\n            // In case of `regular` children, we just add the current route to\n            // the `regular` list if there are any children.\n            if (regular.length > 0) {\n              lists.regular.push({\n                ...route,\n                children: regular,\n              } as RouteObject);\n            }\n\n            return lists;\n          },\n          { skipped: [], regular: [] },\n        ),\n      );\n\n      // We don't need a fallback for the skipped routes, so we have to wrap\n      // them with the route with the `IGNORE_FALLBACK` flag.\n      return [\n        ...(result.skipped.length\n          ? [\n              {\n                children: result.skipped as RouteObject[],\n                handle: {\n                  [RouteHandleFlags.IGNORE_FALLBACK]: true,\n                },\n              },\n            ]\n          : []),\n        ...result.regular,\n      ];\n    });\n\n    return this;\n  }\n}\n"],"version":3}