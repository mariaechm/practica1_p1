{"mappings":"AAAA,SAAS,2BAA4B;AACrC,SAAS,eAAe,+BAAgC;AAGxD,SAAS,mEAA0F;AAEnG,MAAM,YACJ;;;;;;;AA8CF,eAAe,SAAS,2BAA2B,EACjD,WAAW,mBACX,eAAe,uBACf,aAAa,CAAC,QAAQ,MAAO,GAC7B,YAAY,OACZ,QAAQ,OACM,GAAG,CAAE,GAAU;CAC7B,IAAIA;CACJ,IAAIC;CACJ,IAAIC;CACJ,IAAIC;AAEJ,QAAO;EACL,MAAM;EACN,eAAe,EAAE,QAAQ,MAAM,OAAO,EAAE,QAAQ,EAAE,EAAE;GAClD,MAAM,QAAQ,cAAc,KAAK;GACjC,MAAM,gBAAgB,IAAI,IAAI,cAAc;AAE5C,eAAY,IAAI,IAAI,UAAU;AAC9B,aAAU,cAAc,OAAO;AAC/B,aAAU;AAEV,OAAI,OAAO;AACT,YAAQ,MAAM,gCAAgC,OAAO,UAAU,CAAC,EAAE;AAClE,YAAQ,MAAM,oCAAoC,OAAO,cAAc,CAAC,EAAE;AAC1E,YAAQ,MAAM,wBAAwB,OAAO,QAAQ,CAAC,EAAE;GACzD;AACD,iBAAc;IACZ,MAAM,IAAI,IAAI,oBAAoB,YAAY,gBAAgB;IAC9D,MAAM,IAAI,IAAI,kBAAkB;IAChC,SAAS,IAAI,IAAI,gBAAgB;GAClC;EACF;EACD,MAAM,aAAa;AACjB,OAAI;AACF,UAAM,qBAAqB,WAAW,aAAa,YAAY,SAAS,MAAM;GAC/E,SAAQC,GAAY;AACnB,YAAQ,MAAM,OAAO,EAAE,CAAC;GACzB;EACF;EACD,gBAAgB,QAAQ;GACtB,MAAM,MAAM,cAAc,UAAU;GAEpC,MAAM,iBAAiB,CAACC,SAAuB;AAC7C,SAAK,KAAK,WAAW,IAAI,EAAE;AACzB,SAAI,SAAS,cAAc,YAAY,KAAK,EAAE;AAC5C,aAAO,IAAI,KAAK;OAAE,MAAM;OAAU,OAAO;MAAmB,EAAC;KAC9D,WAAU,SAAS,cAAc,YAAY,QAAQ,EAAE;AAEtD;KACD;IACF;AAED,yBAAqB,WAAW,aAAa,YAAY,SAAS,MAAM,CAAC,MAAM,CAACD,MAC9E,QAAQ,MAAM,OAAO,EAAE,CAAC,CACzB;GACF;AAED,UAAO,QAAQ,GAAG,OAAO,eAAe;AACxC,UAAO,QAAQ,GAAG,UAAU,eAAe;AAC3C,UAAO,QAAQ,GAAG,UAAU,eAAe;EAC5C;EACD,UAAU,MAAM,IAAgD;GAC9D,IAAI,eAAe;GACnB,MAAM,uBAAuB,cAAc,UAAU,CAAC,WAAW,MAAM,IAAI;AAC3E,OAAI,GAAG,WAAW,qBAAqB,KAAK,SAAS,GAAG,CAAC,WAAW,IAAI,EAAE;AACxE,QAAI,WAAW;KAYb,MAAM,mBAAmB;AACzB,SAAI,iBAAiB,KAAK,aAAa,EAAE;AACvC,sBAAgB,EAAE,aAAa,UAAU,GAAG,iBAAiB,UAAU,CAAC,EAAE,UAAU,EAAE,aAAa,UACjG,iBAAiB,UAClB,CAAC;KACH;IACF,OAAM;KAEL,MAAM,gBAAgB,4CAA4C,KAAK,aAAa;AAEpF,SAAI,eAAe,QAAQ;MACzB,MAAM,GAAG,aAAa,GAAG;AACzB,uBAAiB,wBAAwB,aAAa,sBAAsB,aAAa;KAC1F;IACF;AAED,WAAO,EACL,MAAM,aACP;GACF;AAED,UAAO;EACR;CACF;AACF","names":["_viewsDir: URL","_outDir: URL","_logger: Logger","runtimeUrls: RuntimeFileUrls","e: unknown","file: string"],"sources":["/opt/agent/work/1af72d8adc613024/hilla/packages/ts/file-router/src/vite-plugin.ts"],"sourcesContent":["import { basename } from 'node:path';\nimport { fileURLToPath, pathToFileURL } from 'node:url';\nimport type { TransformResult } from 'rollup';\nimport type { Logger, Plugin } from 'vite';\nimport { generateRuntimeFiles, type RuntimeFileUrls } from './vite-plugin/generateRuntimeFiles.js';\n\nconst INJECTION =\n  \"if (Object.keys(nextExports).length === 2 && 'default' in nextExports && 'config' in nextExports) {nextExports = { ...nextExports, config: currentExports.config };}\";\n\n/**\n * The options for the Vite file-based router plugin.\n */\nexport type PluginOptions = Readonly<{\n  /**\n   * The base directory for the router. The folders and files in this directory\n   * will be used as route paths.\n   *\n   * @defaultValue `frontend/views`\n   */\n  viewsDir?: URL | string;\n  /**\n   * The directory where the generated view file will be stored.\n   *\n   * @defaultValue `frontend/generated`\n   */\n  generatedDir?: URL | string;\n  /**\n   * The list of extensions that will be collected as routes of the file-based\n   * router.\n   *\n   * @defaultValue `['.tsx', '.jsx']`\n   */\n  extensions?: readonly string[];\n  /**\n   * The flag to indicate whether the plugin is running in development mode.\n   *\n   * @defaultValue `false`\n   */\n  isDevMode?: boolean;\n  /**\n   * The flag to indicate whether to output debug information\n   *\n   * @defaultValue `false`\n   */\n  debug?: boolean;\n}>;\n\n/**\n * A Vite plugin that generates a router from the files in the specific directory.\n *\n * @param options - The plugin options.\n * @returns A Vite plugin.\n */\nexport default function vitePluginFileSystemRouter({\n  viewsDir = 'frontend/views/',\n  generatedDir = 'frontend/generated/',\n  extensions = ['.tsx', '.jsx'],\n  isDevMode = false,\n  debug = false,\n}: PluginOptions = {}): Plugin {\n  let _viewsDir: URL;\n  let _outDir: URL;\n  let _logger: Logger;\n  let runtimeUrls: RuntimeFileUrls;\n\n  return {\n    name: 'vite-plugin-file-router',\n    configResolved({ logger, root, build: { outDir } }) {\n      const _root = pathToFileURL(root);\n      const _generatedDir = new URL(generatedDir, _root);\n\n      _viewsDir = new URL(viewsDir, _root);\n      _outDir = pathToFileURL(outDir);\n      _logger = logger;\n\n      if (debug) {\n        _logger.info(`The directory of route files: ${String(_viewsDir)}`);\n        _logger.info(`The directory of generated files: ${String(_generatedDir)}`);\n        _logger.info(`The output directory: ${String(_outDir)}`);\n      }\n      runtimeUrls = {\n        json: new URL('file-routes.json', isDevMode ? _generatedDir : _outDir),\n        code: new URL('file-routes.ts', _generatedDir),\n        layouts: new URL('layouts.json', _generatedDir),\n      };\n    },\n    async buildStart() {\n      try {\n        await generateRuntimeFiles(_viewsDir, runtimeUrls, extensions, _logger, debug);\n      } catch (e: unknown) {\n        _logger.error(String(e));\n      }\n    },\n    configureServer(server) {\n      const dir = fileURLToPath(_viewsDir);\n\n      const changeListener = (file: string): void => {\n        if (!file.startsWith(dir)) {\n          if (file === fileURLToPath(runtimeUrls.json)) {\n            server.hot.send({ type: 'custom', event: 'fs-route-update' });\n          } else if (file !== fileURLToPath(runtimeUrls.layouts)) {\n            // outside views folder, only changes to layouts file should trigger files generation\n            return;\n          }\n        }\n\n        generateRuntimeFiles(_viewsDir, runtimeUrls, extensions, _logger, debug).catch((e: unknown) =>\n          _logger.error(String(e)),\n        );\n      };\n\n      server.watcher.on('add', changeListener);\n      server.watcher.on('change', changeListener);\n      server.watcher.on('unlink', changeListener);\n    },\n    transform(code, id): Promise<TransformResult> | TransformResult {\n      let modifiedCode = code;\n      const viewsDirUsingSlashes = fileURLToPath(_viewsDir).replaceAll('\\\\', '/');\n      if (id.startsWith(viewsDirUsingSlashes) && !basename(id).startsWith('_')) {\n        if (isDevMode) {\n          // To enable HMR for route files with exported configurations, we need\n          // to address a limitation in `react-refresh`. This library requires\n          // strict equality (`===`) for non-component exports. However, the\n          // dynamic nature of HMR makes maintaining this equality between object\n          // literals challenging.\n          //\n          // To work around this, we implement a strategy that preserves the\n          // reference to the original configuration object (`currentExports.config`),\n          // replacing any newly created configuration objects (`nextExports.config`)\n          // with it. This ensures that the HMR mechanism perceives the\n          // configuration as unchanged.\n          const injectionPattern = /import\\.meta\\.hot\\.accept[\\s\\S]+if\\s\\(!nextExports\\)\\s+return;/gu;\n          if (injectionPattern.test(modifiedCode)) {\n            modifiedCode = `${modifiedCode.substring(0, injectionPattern.lastIndex)}${INJECTION}${modifiedCode.substring(\n              injectionPattern.lastIndex,\n            )}`;\n          }\n        } else {\n          // In production mode, the function name is assigned as name to the function itself to avoid minification\n          const functionNames = /export\\s+default\\s+(?:function\\s+)?(\\w+)/u.exec(modifiedCode);\n\n          if (functionNames?.length) {\n            const [, functionName] = functionNames;\n            modifiedCode += `Object.defineProperty(${functionName}, 'name', { value: '${functionName}' });\\n`;\n          }\n        }\n\n        return {\n          code: modifiedCode,\n        };\n      }\n\n      return undefined;\n    },\n  };\n}\n"],"version":3}