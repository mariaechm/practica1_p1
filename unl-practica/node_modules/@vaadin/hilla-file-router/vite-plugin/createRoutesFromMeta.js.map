{"mappings":"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","names":["#manager","#views","views: readonly RouteMeta[]","errors: string[]","_children: readonly CallExpression[] | undefined","mod: Identifier | undefined","#createRouteData","path: string","extension?: Readonly<Record<string, unknown>>","children?: readonly CallExpression[]","extendModuleId: Identifier | undefined","urls: RuntimeFileUrls"],"sources":["/opt/agent/work/1af72d8adc613024/hilla/packages/ts/file-router/src/vite-plugin/createRoutesFromMeta.ts"],"sourcesContent":["import { template, transform as transformer } from '@vaadin/hilla-generator-utils/ast.js';\nimport createSourceFile from '@vaadin/hilla-generator-utils/createSourceFile.js';\nimport DependencyManager from '@vaadin/hilla-generator-utils/dependencies/DependencyManager.js';\nimport PathManager from '@vaadin/hilla-generator-utils/dependencies/PathManager.js';\nimport ts, { type CallExpression, type Identifier, type VariableStatement } from 'typescript';\n\nimport { transformTree } from '../shared/transformTree.js';\nimport type { RouteMeta } from './collectRoutesFromFS.js';\nimport type { RuntimeFileUrls } from './generateRuntimeFiles.js';\nimport { convertFSRouteSegmentToURLPatternFormat } from './utils.js';\n\nconst printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });\n\nconst fileExtensions = ['.ts', '.tsx', '.js', '.jsx'];\n\nclass RouteFromMetaProcessor {\n  readonly #manager: DependencyManager;\n  readonly #views: readonly RouteMeta[];\n\n  constructor(views: readonly RouteMeta[], { code: codeFile }: RuntimeFileUrls) {\n    this.#views = views;\n\n    const codeDir = new URL('./', codeFile);\n    this.#manager = new DependencyManager(new PathManager({ extension: '.js', relativeTo: codeDir }));\n  }\n\n  /**\n   * Loads all the files from the received metadata and creates a framework-agnostic route tree.\n   *\n   * @param views - The abstract route tree.\n   * @param generatedDir - The directory where the generated view file will be stored.\n   */\n  process(): string {\n    const {\n      paths,\n      imports: { named, namespace },\n    } = this.#manager;\n    const errors: string[] = [];\n\n    const routes = transformTree<readonly RouteMeta[], readonly CallExpression[]>(this.#views, null, (metas, next) => {\n      errors.push(\n        ...metas\n          .map((route) => route.path)\n          .filter((item, index, arr) => arr.indexOf(item) !== index)\n          .map((dup) => `console.error(\"Two views share the same path: ${dup}\");`),\n      );\n\n      return metas.map(({ file, layout, path, children, flowLayout }) => {\n        let _children: readonly CallExpression[] | undefined;\n\n        if (children) {\n          _children = next(children);\n        }\n\n        let mod: Identifier | undefined;\n        if (file) {\n          const fileExt = fileExtensions.find((ext) => file.pathname.endsWith(ext));\n          mod = namespace.add(paths.createRelativePath(file, fileExt), `Page`);\n        } else if (layout) {\n          const fileExt = fileExtensions.find((ext) => layout.pathname.endsWith(ext));\n          mod = namespace.add(paths.createRelativePath(layout, fileExt), `Layout`);\n        }\n\n        const moduleExtension = flowLayout ? { flowLayout } : undefined;\n\n        return this.#createRouteData(convertFSRouteSegmentToURLPatternFormat(path), mod, moduleExtension, _children);\n      });\n    });\n\n    const agnosticRouteId =\n      named.getIdentifier('@vaadin/hilla-file-router/types.js', 'AgnosticRoute') ??\n      named.add('@vaadin/hilla-file-router/types.js', 'AgnosticRoute', true);\n\n    let routeDeclaration = template(\n      `${errors.join('\\n')}\n\nconst routes: readonly AGNOSTIC_ROUTE[] = ROUTE;\n\nexport default routes;\n`,\n      [\n        transformer((node) =>\n          ts.isIdentifier(node) && node.text === 'ROUTE' ? ts.factory.createArrayLiteralExpression(routes, true) : node,\n        ),\n        transformer((node) => (ts.isIdentifier(node) && node.text === 'AGNOSTIC_ROUTE' ? agnosticRouteId : node)),\n      ],\n    );\n\n    routeDeclaration = [...this.#manager.imports.toCode(), ...routeDeclaration];\n\n    const file = createSourceFile(routeDeclaration, 'file-routes.ts');\n    return printer.printFile(file);\n  }\n\n  /**\n   * Create an abstract route creation function call. The nested function calls\n   * create a route tree.\n   *\n   * @param path - The path of the route.\n   * @param mod - The name of the route module imported as a namespace.\n   * @param children - The list of child route call expressions.\n   */\n  #createRouteData(\n    path: string,\n    mod: Identifier | undefined,\n    extension?: Readonly<Record<string, unknown>>,\n    children?: readonly CallExpression[],\n  ): CallExpression {\n    const { named } = this.#manager.imports;\n\n    let extendModuleId: Identifier | undefined;\n    let modNode = '';\n\n    if (extension) {\n      extendModuleId =\n        named.getIdentifier('@vaadin/hilla-file-router/runtime.js', 'extendModule') ??\n        named.add('@vaadin/hilla-file-router/runtime.js', 'extendModule');\n      modNode = `, EXTEND_MODULE(MOD, ${JSON.stringify(extension)})`;\n    } else if (mod) {\n      modNode = `, MOD`;\n    }\n\n    const createRouteId =\n      named.getIdentifier('@vaadin/hilla-file-router/runtime.js', 'createRoute') ??\n      named.add('@vaadin/hilla-file-router/runtime.js', 'createRoute');\n\n    return template(\n      `const route = CREATE_ROUTE(\"${path}\", ${modNode}${children ? `, CHILDREN` : ''})`,\n      ([statement]) => (statement as VariableStatement).declarationList.declarations[0].initializer as CallExpression,\n      [\n        transformer((node) =>\n          ts.isIdentifier(node) && node.text === 'CHILDREN'\n            ? ts.factory.createArrayLiteralExpression(children, true)\n            : node,\n        ),\n        transformer((node) => (ts.isIdentifier(node) && node.text === 'MOD' ? (mod ?? ts.factory.createNull()) : node)),\n        transformer((node) => (ts.isIdentifier(node) && node.text === 'EXTEND_MODULE' ? extendModuleId : node)),\n        transformer((node) => (ts.isIdentifier(node) && node.text === 'CREATE_ROUTE' ? createRouteId : node)),\n      ],\n    );\n  }\n}\n\nexport default function createRoutesFromMeta(views: readonly RouteMeta[], urls: RuntimeFileUrls): string {\n  return new RouteFromMetaProcessor(views, urls).process();\n}\n"],"version":3}