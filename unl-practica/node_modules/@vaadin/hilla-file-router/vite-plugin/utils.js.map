{"mappings":"AAAA,SAAS,mDAAoD;AAE7D,OAAO,MAAMA,oBAAyD,IAAI,IAAI;CAC5E,CAAC,eAAe,UAAU,kBAAmB;CAC7C,CAAC,eAAe,UAAU,gBAAiB;CAC3C,CAAC,eAAe,UAAU,YAAa;AACxC;AAGD,SAAS,YAAYC,MAA8B;AAEjD,SAAQ,MAAR;EACE,KAAK,eAAe,SAClB,QAAO;EACT,KAAK,eAAe,SAClB,QAAO;EACT,KAAK,eAAe,SAClB,QAAO;CACV;AACF;;;;;;;;;;;;;;AAeD,OAAO,SAAS,wCAAwCC,SAAyB;CAC/E,IAAI,MAAM;AAEV,mBAAkB,QAAQ,CAAC,SAAS,SAAS;AAC3C,QAAM,IAAI,WAAW,SAAS,YAAY,KAAK,CAAC;CACjD,EAAC;AAEF,QAAO;AACR;;;;;;;AAQD,OAAO,SAAS,iCAAiCA,SAA2D;CAC1G,IAAI,WAAW;CACf,MAAMC,SAAyC,CAAE;AAEjD,MAAK,MAAM,CAAC,MAAM,QAAQ,IAAI,mBAAmB;EAC/C,MAAM,WAAW,IAAI,OAAO,QAAQ,QAAQ,QAAQ;AACpD,aAAW,SAAS,WAAW,UAAU,CAAC,UAAU;GAClD,MAAM,MAAM,MAAM,WAAW,SAAS,YAAY,KAAK,CAAC;AACxD,UAAO,OAAO;AACd,UAAO;EACR,EAAC;CACH;AAED,QAAO;AACR;;;;;AAMD,OAAO,SAAS,QAAQC,MAAsB;CAC5C,IAAI,MAAM;AAEV,MAAK,MAAM,WAAW,kBAAkB,QAAQ,EAAE;AAChD,QAAM,IAAI,WAAW,SAAS,KAAK;CACpC;AAED,QAAO;AACR","names":["routeParamTypeMap: ReadonlyMap<RouteParamType, RegExp>","type: RouteParamType","segment: string","params: Record<string, RouteParamType>","path: string"],"sources":["/opt/agent/work/1af72d8adc613024/hilla/packages/ts/file-router/src/vite-plugin/utils.ts"],"sourcesContent":["import { RouteParamType } from '../shared/routeParamType.js';\n\nexport const routeParamTypeMap: ReadonlyMap<RouteParamType, RegExp> = new Map([\n  [RouteParamType.Wildcard, /\\{\\.\\.\\.(.+)\\}/gu], // e.g. \"{...wildcard}\"\n  [RouteParamType.Optional, /\\{\\{(.+)\\}\\}/gu], // e.g. \"{{param}}\"\n  [RouteParamType.Required, /\\{(.+)\\}/gu], // e.g. \"{param}\"\n]);\n\n// eslint-disable-next-line @typescript-eslint/consistent-return\nfunction getReplacer(type: RouteParamType): string {\n  // eslint-disable-next-line default-case\n  switch (type) {\n    case RouteParamType.Wildcard:\n      return '*';\n    case RouteParamType.Optional:\n      return ':$1?';\n    case RouteParamType.Required:\n      return ':$1';\n  }\n}\n\n/**\n * Converts a file system pattern to an URL pattern string.\n *\n * @param segment - a string representing a file system pattern:\n * - `{param}` - for a required single parameter;\n * - `{{param}}` - for an optional single parameter;\n * - `{...wildcard}` - for multiple parameters, including none.\n *\n * @returns a string representing a URL pattern, respectively:\n * - `:param`;\n * - `:param?`;\n * - `*`.\n */\nexport function convertFSRouteSegmentToURLPatternFormat(segment: string): string {\n  let res = segment;\n\n  routeParamTypeMap.forEach((pattern, type) => {\n    res = res.replaceAll(pattern, getReplacer(type));\n  });\n\n  return res;\n}\n\n/**\n * Extracts the parameter name and its type from the route segment.\n *\n * @param segment - A part of the FS route URL.\n * @returns A map of parameter names and their types.\n */\nexport function extractParameterFromRouteSegment(segment: string): Readonly<Record<string, RouteParamType>> {\n  let _segment = segment;\n  const params: Record<string, RouteParamType> = {};\n\n  for (const [type, pattern] of routeParamTypeMap) {\n    const _pattern = new RegExp(pattern.source, pattern.flags);\n    _segment = _segment.replaceAll(_pattern, (match) => {\n      const key = match.replaceAll(pattern, getReplacer(type));\n      params[key] = type;\n      return '';\n    });\n  }\n\n  return params;\n}\n\n/**\n * A small helper function that clears route path of the control characters in\n * order to sort the routes alphabetically.\n */\nexport function cleanUp(path: string): string {\n  let res = path;\n\n  for (const pattern of routeParamTypeMap.values()) {\n    res = res.replaceAll(pattern, '$1');\n  }\n\n  return res;\n}\n"],"version":3}