import { isEmptyObject, isObjectSchema } from "@vaadin/hilla-generator-core/Schema.js";
import ts from "typescript";
import TypeSchemaProcessor from "./TypeSchemaProcessor.js";
import { defaultMediaType } from "./utils.js";
const DEFAULT_INIT_PARAM_NAME = "init";
const INIT_TYPE_NAME = "EndpointRequestInit";
const HILLA_FRONTEND_NAME = "@vaadin/hilla-frontend";
export default class EndpointMethodRequestBodyProcessor {
	#dependencies;
	#transferTypes;
	#owner;
	#requestBody;
	constructor(requestBody, dependencies, transferTypes, owner) {
		this.#owner = owner;
		this.#dependencies = dependencies;
		this.#requestBody = requestBody ? owner.resolver.resolve(requestBody) : undefined;
		this.#transferTypes = transferTypes;
	}
	process() {
		const { imports, paths } = this.#dependencies;
		const path = paths.createBareModulePath(HILLA_FRONTEND_NAME);
		const initTypeIdentifier = imports.named.getIdentifier(path, INIT_TYPE_NAME) ?? imports.named.add(path, INIT_TYPE_NAME);
		if (!this.#requestBody) {
			return {
				initParam: ts.factory.createIdentifier(DEFAULT_INIT_PARAM_NAME),
				packedParameters: ts.factory.createObjectLiteralExpression(),
				parameters: [ts.factory.createParameterDeclaration(undefined, undefined, DEFAULT_INIT_PARAM_NAME, ts.factory.createToken(ts.SyntaxKind.QuestionToken), ts.factory.createTypeReferenceNode(initTypeIdentifier))]
			};
		}
		const parameterData = this.#extractParameterData(this.#requestBody.content[defaultMediaType].schema);
		const parameterNames = parameterData.map(([name]) => name);
		let initParamName = DEFAULT_INIT_PARAM_NAME;
		while (parameterNames.includes(initParamName)) {
			initParamName = `_${initParamName}`;
		}
		return {
			initParam: ts.factory.createIdentifier(initParamName),
			packedParameters: ts.factory.createObjectLiteralExpression(parameterData.map(([name]) => ts.factory.createShorthandPropertyAssignment(name))),
			parameters: [...parameterData.map(([name, schema]) => {
				const nodes = new TypeSchemaProcessor(schema, this.#dependencies, this.#transferTypes).process();
				return ts.factory.createParameterDeclaration(undefined, undefined, name, undefined, ts.factory.createUnionTypeNode(nodes));
			}), ts.factory.createParameterDeclaration(undefined, undefined, initParamName, ts.factory.createToken(ts.SyntaxKind.QuestionToken), ts.factory.createTypeReferenceNode(initTypeIdentifier))]
		};
	}
	#extractParameterData(basicSchema) {
		if (!basicSchema) {
			return [];
		}
		const { logger, resolver } = this.#owner;
		const resolvedSchema = resolver.resolve(basicSchema);
		if (isObjectSchema(resolvedSchema) && !isEmptyObject(resolvedSchema)) {
			return Object.entries(resolvedSchema.properties);
		}
		logger.warn("A schema provided for endpoint method's 'requestBody' is not supported");
		return [];
	}
}
//# sourceMappingURL=./EndpointMethodRequestBodyProcessor.js.map