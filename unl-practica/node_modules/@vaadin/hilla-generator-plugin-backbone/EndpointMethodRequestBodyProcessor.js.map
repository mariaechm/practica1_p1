{"mappings":"AACA,SACE,eACA,8DAG8C;AAIhD,OAAO,oBAAmG;AAC1G,OAAO,mDAAoD;AAC3D,SAAS,oCAAqC;AAU9C,MAAM,0BAA0B;AAChC,MAAM,iBAAiB;AACvB,MAAM,sBAAsB;AAE5B,eAAe,MAAM,mCAAmC;CACtD,AAASA;CACT,AAASC;CACT,AAASC;CACT,AAASC;CAET,YACEC,aACAC,cACAC,eACAC,OACA;AACA,OAAKL,SAAS;AACd,OAAKF,gBAAgB;AACrB,OAAKG,eAAe,cAAc,MAAM,SAAS,QAAQ,YAAY,GAAG;AACxE,OAAKF,iBAAiB;CACvB;CAED,UAAqD;EACnD,MAAM,EAAE,SAAS,OAAO,GAAG,KAAKD;EAChC,MAAM,OAAO,MAAM,qBAAqB,oBAAoB;EAC5D,MAAM,qBACJ,QAAQ,MAAM,cAAc,MAAM,eAAe,IAAI,QAAQ,MAAM,IAAI,MAAM,eAAe;AAE9F,OAAK,KAAKG,cAAc;AACtB,UAAO;IACL,WAAW,GAAG,QAAQ,iBAAiB,wBAAwB;IAC/D,kBAAkB,GAAG,QAAQ,+BAA+B;IAC5D,YAAY,CACV,GAAG,QAAQ,2BACT,WACA,WACA,yBACA,GAAG,QAAQ,YAAY,GAAG,WAAW,cAAc,EACnD,GAAG,QAAQ,wBAAwB,mBAAmB,CACvD,AACF;GACF;EACF;EAED,MAAM,gBAAgB,KAAKK,sBAAsB,KAAKL,aAAa,QAAQ,kBAAkB,OAAO;EACpG,MAAM,iBAAiB,cAAc,IAAI,CAAC,CAAC,KAAK,KAAK,KAAK;EAC1D,IAAI,gBAAgB;AAEpB,SAAO,eAAe,SAAS,cAAc,EAAE;AAC7C,oBAAiB,GAAG,cAAc;EACnC;AAED,SAAO;GACL,WAAW,GAAG,QAAQ,iBAAiB,cAAc;GACrD,kBAAkB,GAAG,QAAQ,8BAC3B,cAAc,IAAI,CAAC,CAAC,KAAK,KAAK,GAAG,QAAQ,kCAAkC,KAAK,CAAC,CAClF;GACD,YAAY,CACV,GAAG,cAAc,IAAI,CAAC,CAAC,MAAM,OAAO,KAAK;IACvC,MAAM,QAAQ,IAAI,oBAAoB,QAAQ,KAAKH,eAAe,KAAKC,gBAAgB,SAAS;AAEhG,WAAO,GAAG,QAAQ,2BAChB,WACA,WACA,MACA,WACA,GAAG,QAAQ,oBAAoB,MAAM,CACtC;GACF,EAAC,EACF,GAAG,QAAQ,2BACT,WACA,WACA,eACA,GAAG,QAAQ,YAAY,GAAG,WAAW,cAAc,EACnD,GAAG,QAAQ,wBAAwB,mBAAmB,CACvD,AACF;EACF;CACF;CAED,sBACEQ,aACkC;AAClC,OAAK,aAAa;AAChB,UAAO,CAAE;EACV;EAED,MAAM,EAAE,QAAQ,UAAU,GAAG,KAAKP;EAElC,MAAM,iBAAiB,SAAS,QAAQ,YAAY;AAEpD,MAAI,eAAe,eAAe,KAAK,cAAc,eAAe,EAAE;AACpE,UAAO,OAAO,QAAS,eAAwC,WAAW;EAC3E;AAED,SAAO,KAAK,yEAAyE;AACrF,SAAO,CAAE;CACV;AACF","names":["#dependencies","#transferTypes","#owner","#requestBody","requestBody: OpenAPIV3.ReferenceObject | OpenAPIV3.RequestBodyObject | undefined","dependencies: DependencyManager","transferTypes: TransferTypes","owner: Plugin","#extractParameterData","basicSchema?: OpenAPIV3.ReferenceObject | OpenAPIV3.SchemaObject"],"sources":["/opt/agent/work/1af72d8adc613024/hilla/packages/ts/generator-plugin-backbone/src/EndpointMethodRequestBodyProcessor.ts"],"sourcesContent":["import type Plugin from '@vaadin/hilla-generator-core/Plugin.js';\nimport {\n  isEmptyObject,\n  isObjectSchema,\n  type NonEmptyObjectSchema,\n  type Schema,\n} from '@vaadin/hilla-generator-core/Schema.js';\nimport type { TransferTypes } from '@vaadin/hilla-generator-core/SharedStorage.js';\nimport type DependencyManager from '@vaadin/hilla-generator-utils/dependencies/DependencyManager.js';\nimport type { OpenAPIV3 } from 'openapi-types';\nimport ts, { type Identifier, type ObjectLiteralExpression, type ParameterDeclaration } from 'typescript';\nimport TypeSchemaProcessor from './TypeSchemaProcessor.js';\nimport { defaultMediaType } from './utils.js';\n\nexport type EndpointMethodRequestBody = OpenAPIV3.RequestBodyObject;\n\nexport type EndpointMethodRequestBodyProcessingResult = Readonly<{\n  parameters: readonly ParameterDeclaration[];\n  packedParameters?: ObjectLiteralExpression;\n  initParam: Identifier;\n}>;\n\nconst DEFAULT_INIT_PARAM_NAME = 'init';\nconst INIT_TYPE_NAME = 'EndpointRequestInit';\nconst HILLA_FRONTEND_NAME = '@vaadin/hilla-frontend';\n\nexport default class EndpointMethodRequestBodyProcessor {\n  readonly #dependencies: DependencyManager;\n  readonly #transferTypes: TransferTypes;\n  readonly #owner: Plugin;\n  readonly #requestBody?: EndpointMethodRequestBody;\n\n  constructor(\n    requestBody: OpenAPIV3.ReferenceObject | OpenAPIV3.RequestBodyObject | undefined,\n    dependencies: DependencyManager,\n    transferTypes: TransferTypes,\n    owner: Plugin,\n  ) {\n    this.#owner = owner;\n    this.#dependencies = dependencies;\n    this.#requestBody = requestBody ? owner.resolver.resolve(requestBody) : undefined;\n    this.#transferTypes = transferTypes;\n  }\n\n  process(): EndpointMethodRequestBodyProcessingResult {\n    const { imports, paths } = this.#dependencies;\n    const path = paths.createBareModulePath(HILLA_FRONTEND_NAME);\n    const initTypeIdentifier =\n      imports.named.getIdentifier(path, INIT_TYPE_NAME) ?? imports.named.add(path, INIT_TYPE_NAME);\n\n    if (!this.#requestBody) {\n      return {\n        initParam: ts.factory.createIdentifier(DEFAULT_INIT_PARAM_NAME),\n        packedParameters: ts.factory.createObjectLiteralExpression(),\n        parameters: [\n          ts.factory.createParameterDeclaration(\n            undefined,\n            undefined,\n            DEFAULT_INIT_PARAM_NAME,\n            ts.factory.createToken(ts.SyntaxKind.QuestionToken),\n            ts.factory.createTypeReferenceNode(initTypeIdentifier),\n          ),\n        ],\n      };\n    }\n\n    const parameterData = this.#extractParameterData(this.#requestBody.content[defaultMediaType].schema);\n    const parameterNames = parameterData.map(([name]) => name);\n    let initParamName = DEFAULT_INIT_PARAM_NAME;\n\n    while (parameterNames.includes(initParamName)) {\n      initParamName = `_${initParamName}`;\n    }\n\n    return {\n      initParam: ts.factory.createIdentifier(initParamName),\n      packedParameters: ts.factory.createObjectLiteralExpression(\n        parameterData.map(([name]) => ts.factory.createShorthandPropertyAssignment(name)),\n      ),\n      parameters: [\n        ...parameterData.map(([name, schema]) => {\n          const nodes = new TypeSchemaProcessor(schema, this.#dependencies, this.#transferTypes).process();\n\n          return ts.factory.createParameterDeclaration(\n            undefined,\n            undefined,\n            name,\n            undefined,\n            ts.factory.createUnionTypeNode(nodes),\n          );\n        }),\n        ts.factory.createParameterDeclaration(\n          undefined,\n          undefined,\n          initParamName,\n          ts.factory.createToken(ts.SyntaxKind.QuestionToken),\n          ts.factory.createTypeReferenceNode(initTypeIdentifier),\n        ),\n      ],\n    };\n  }\n\n  #extractParameterData(\n    basicSchema?: OpenAPIV3.ReferenceObject | OpenAPIV3.SchemaObject,\n  ): Array<readonly [string, Schema]> {\n    if (!basicSchema) {\n      return [];\n    }\n\n    const { logger, resolver } = this.#owner;\n\n    const resolvedSchema = resolver.resolve(basicSchema);\n\n    if (isObjectSchema(resolvedSchema) && !isEmptyObject(resolvedSchema)) {\n      return Object.entries((resolvedSchema as NonEmptyObjectSchema).properties);\n    }\n\n    logger.warn(\"A schema provided for endpoint method's 'requestBody' is not supported\");\n    return [];\n  }\n}\n"],"version":3}