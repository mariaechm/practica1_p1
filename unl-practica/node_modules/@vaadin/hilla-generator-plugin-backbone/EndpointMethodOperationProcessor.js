import ClientPlugin from "@vaadin/hilla-generator-plugin-client";
import equal from "fast-deep-equal";
import { OpenAPIV3 } from "openapi-types";
import ts from "typescript";
import EndpointMethodRequestBodyProcessor from "./EndpointMethodRequestBodyProcessor.js";
import EndpointMethodResponseProcessor from "./EndpointMethodResponseProcessor.js";
export default class EndpointMethodOperationProcessor {
	static createProcessor(httpMethod, endpointName, endpointMethodName, operation, dependencies, transferTypes, owner) {
		switch (httpMethod) {
			case OpenAPIV3.HttpMethods.POST: {
				return new EndpointMethodOperationPOSTProcessor(endpointName, endpointMethodName, operation, dependencies, transferTypes, owner);
			}
			default:
				owner.logger.warn(`Processing ${httpMethod.toUpperCase()} currently is not supported`);
				return undefined;
		}
	}
}
class EndpointMethodOperationPOSTProcessor extends EndpointMethodOperationProcessor {
	#dependencies;
	#transferTypes;
	#endpointMethodName;
	#endpointName;
	#operation;
	#owner;
	constructor(endpointName, endpointMethodName, operation, dependencies, transferTypes, owner) {
		super();
		this.#owner = owner;
		this.#dependencies = dependencies;
		this.#endpointName = endpointName;
		this.#endpointMethodName = endpointMethodName;
		this.#operation = operation;
		this.#transferTypes = transferTypes;
	}
	async process(outputDir) {
		const { exports, imports, paths } = this.#dependencies;
		this.#owner.logger.debug(`${this.#endpointName}.${this.#endpointMethodName} - processing POST method`);
		const { initParam, packedParameters, parameters } = new EndpointMethodRequestBodyProcessor(this.#operation.requestBody, this.#dependencies, this.#transferTypes, this.#owner).process();
		const methodIdentifier = exports.named.add(this.#endpointMethodName);
		const clientLibIdentifier = imports.default.getIdentifier(paths.createRelativePath(await ClientPlugin.getClientFileName(outputDir)));
		const callExpression = ts.factory.createCallExpression(ts.factory.createPropertyAccessExpression(clientLibIdentifier, ts.factory.createIdentifier("call")), undefined, [
			ts.factory.createStringLiteral(this.#endpointName),
			ts.factory.createStringLiteral(this.#endpointMethodName),
			packedParameters,
			initParam
		].filter(Boolean));
		const responseType = this.#prepareResponseType();
		return ts.factory.createFunctionDeclaration([ts.factory.createToken(ts.SyntaxKind.AsyncKeyword)], undefined, methodIdentifier, undefined, parameters, ts.factory.createTypeReferenceNode("Promise", [responseType]), ts.factory.createBlock([ts.factory.createReturnStatement(callExpression)]));
	}
	#prepareResponseType() {
		this.#owner.logger.debug(`${this.#endpointName}.${this.#endpointMethodName} POST - processing response type`);
		const responseTypes = Object.entries(this.#operation.responses).flatMap(([code, response]) => new EndpointMethodResponseProcessor(code, response, this.#dependencies, this.#transferTypes, this.#owner).process()).filter((value, index, arr) => arr.findIndex((v) => equal(v, value)) === index);
		if (responseTypes.length === 0) {
			return ts.factory.createKeywordTypeNode(ts.SyntaxKind.VoidKeyword);
		}
		return ts.factory.createUnionTypeNode(responseTypes);
	}
}
//# sourceMappingURL=./EndpointMethodOperationProcessor.js.map