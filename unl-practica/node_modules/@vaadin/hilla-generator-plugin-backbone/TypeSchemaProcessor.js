import { convertFullyQualifiedNameToRelativePath, convertReferenceSchemaToFullyQualifiedName, convertReferenceSchemaToSpecifier, decomposeSchema, isArraySchema, isBooleanSchema, isComposedSchema, isIntegerSchema, isMapSchema, isNullableSchema, isNumberSchema, isReferenceSchema, isStringSchema } from "@vaadin/hilla-generator-core/Schema.js";
import ts from "typescript";
import { findTypeArguments, findTypeVariable } from "./utils.js";
function createBoolean() {
	return ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);
}
function createNumber() {
	return ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);
}
function createString() {
	return ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);
}
function createUndefined() {
	return ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);
}
function createUnknown() {
	return ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);
}
function unwrapPossiblyNullableSchema(schema) {
	if (isComposedSchema(schema)) {
		const [result] = decomposeSchema(schema);
		return result;
	}
	return schema;
}
export default class TypeSchemaProcessor {
	#dependencies;
	#schema;
	#transferTypes;
	constructor(schema, dependencies, transferTypes) {
		this.#schema = schema;
		this.#dependencies = dependencies;
		this.#transferTypes = transferTypes;
	}
	process() {
		let node;
		const unwrappedSchema = unwrapPossiblyNullableSchema(this.#schema);
		const typeVariable = findTypeVariable(this.#schema);
		if (typeVariable) {
			return [ts.factory.createTypeReferenceNode(typeVariable)];
		}
		if (isReferenceSchema(unwrappedSchema)) {
			const typeArguments = this.#processTypeArguments(this.#schema);
			node = this.#processReference(unwrappedSchema, typeArguments);
		} else if (isArraySchema(unwrappedSchema)) {
			node = this.#processArray(unwrappedSchema);
		} else if (isMapSchema(unwrappedSchema)) {
			node = this.#processMap(unwrappedSchema);
		} else if (isBooleanSchema(unwrappedSchema)) {
			node = createBoolean();
		} else if (isIntegerSchema(unwrappedSchema) || isNumberSchema(unwrappedSchema)) {
			node = createNumber();
		} else if (isStringSchema(unwrappedSchema)) {
			node = createString();
		} else {
			node = createUnknown();
		}
		return isNullableSchema(this.#schema) ? [node, createUndefined()] : [node];
	}
	#processArray(schema) {
		const nodes = new TypeSchemaProcessor(schema.items, this.#dependencies, this.#transferTypes).process();
		return ts.factory.createTypeReferenceNode("Array", [ts.factory.createUnionTypeNode(nodes)]);
	}
	#processMap({ additionalProperties: valuesType }) {
		let valuesTypeNode;
		if (typeof valuesType !== "boolean") {
			const nodes = new TypeSchemaProcessor(valuesType, this.#dependencies, this.#transferTypes).process();
			valuesTypeNode = ts.factory.createUnionTypeNode(nodes);
		} else {
			valuesTypeNode = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);
		}
		return ts.factory.createTypeReferenceNode("Record", [ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword), valuesTypeNode]);
	}
	#processTypeArguments(schema) {
		return findTypeArguments(schema)?.allOf.map((s) => new TypeSchemaProcessor(s, this.#dependencies, this.#transferTypes).process()).map((t) => ts.factory.createUnionTypeNode(t));
	}
	#processReference(schema, typeArguments) {
		const { imports, paths } = this.#dependencies;
		const fullyQualifiedName = convertReferenceSchemaToFullyQualifiedName(schema);
		if (this.#transferTypes.has(fullyQualifiedName)) {
			return this.#transferTypes.get(fullyQualifiedName)(typeArguments);
		}
		const specifier = convertReferenceSchemaToSpecifier(schema);
		const path = paths.createRelativePath(convertFullyQualifiedNameToRelativePath(fullyQualifiedName));
		const identifier = imports.default.getIdentifier(path) ?? imports.default.add(path, specifier, true);
		return ts.factory.createTypeReferenceNode(identifier, typeArguments);
	}
}
//# sourceMappingURL=./TypeSchemaProcessor.js.map