{"mappings":"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","names":["schema: Schema","#dependencies","#schema","#transferTypes","dependencies: DependencyManager","transferTypes: Map<string, TransferTypeMaker>","node: TypeNode","#processTypeArguments","#processReference","#processArray","#processMap","schema: ArraySchema","valuesTypeNode: TypeNode","schema: ReferenceSchema","typeArguments: readonly TypeNode[] | undefined"],"sources":["/opt/agent/work/1af72d8adc613024/hilla/packages/ts/generator-plugin-backbone/src/TypeSchemaProcessor.ts"],"sourcesContent":["import {\n  type ArraySchema,\n  convertFullyQualifiedNameToRelativePath,\n  convertReferenceSchemaToFullyQualifiedName,\n  convertReferenceSchemaToSpecifier,\n  decomposeSchema,\n  isArraySchema,\n  isBooleanSchema,\n  isComposedSchema,\n  isIntegerSchema,\n  isMapSchema,\n  isNullableSchema,\n  isNumberSchema,\n  isReferenceSchema,\n  isStringSchema,\n  type MapSchema,\n  type NonComposedSchema,\n  type ReferenceSchema,\n  type Schema,\n} from '@vaadin/hilla-generator-core/Schema.js';\nimport type { TransferTypeMaker } from '@vaadin/hilla-generator-core/SharedStorage.js';\nimport type DependencyManager from '@vaadin/hilla-generator-utils/dependencies/DependencyManager.js';\nimport ts, { type TypeNode } from 'typescript';\nimport { findTypeArguments, findTypeVariable } from './utils.js';\n\nfunction createBoolean(): TypeNode {\n  return ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);\n}\n\nfunction createNumber(): TypeNode {\n  return ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);\n}\n\nfunction createString(): TypeNode {\n  return ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);\n}\n\nfunction createUndefined(): TypeNode {\n  return ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);\n}\n\nfunction createUnknown(): TypeNode {\n  return ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);\n}\n\nfunction unwrapPossiblyNullableSchema(schema: Schema): NonComposedSchema {\n  if (isComposedSchema(schema)) {\n    const [result] = decomposeSchema(schema);\n\n    return result as NonComposedSchema;\n  }\n\n  return schema as NonComposedSchema;\n}\n\nexport default class TypeSchemaProcessor {\n  declare ['constructor']: typeof TypeSchemaProcessor;\n  readonly #dependencies: DependencyManager;\n  readonly #schema: Schema;\n  readonly #transferTypes: Map<string, TransferTypeMaker>;\n\n  constructor(schema: Schema, dependencies: DependencyManager, transferTypes: Map<string, TransferTypeMaker>) {\n    this.#schema = schema;\n    this.#dependencies = dependencies;\n    this.#transferTypes = transferTypes;\n  }\n\n  process(): readonly TypeNode[] {\n    let node: TypeNode;\n\n    const unwrappedSchema = unwrapPossiblyNullableSchema(this.#schema);\n\n    const typeVariable = findTypeVariable(this.#schema);\n    if (typeVariable) {\n      // Type variables are returned directly as they are, no further processing is needed\n      return [ts.factory.createTypeReferenceNode(typeVariable)];\n    }\n\n    if (isReferenceSchema(unwrappedSchema)) {\n      const typeArguments = this.#processTypeArguments(this.#schema);\n      node = this.#processReference(unwrappedSchema, typeArguments);\n    } else if (isArraySchema(unwrappedSchema)) {\n      node = this.#processArray(unwrappedSchema);\n    } else if (isMapSchema(unwrappedSchema)) {\n      node = this.#processMap(unwrappedSchema);\n    } else if (isBooleanSchema(unwrappedSchema)) {\n      node = createBoolean();\n    } else if (isIntegerSchema(unwrappedSchema) || isNumberSchema(unwrappedSchema)) {\n      node = createNumber();\n    } else if (isStringSchema(unwrappedSchema)) {\n      node = createString();\n    } else {\n      node = createUnknown();\n    }\n\n    return isNullableSchema(this.#schema) ? [node, createUndefined()] : [node];\n  }\n\n  #processArray(schema: ArraySchema): TypeNode {\n    const nodes = new TypeSchemaProcessor(schema.items, this.#dependencies, this.#transferTypes).process();\n\n    return ts.factory.createTypeReferenceNode('Array', [ts.factory.createUnionTypeNode(nodes)]);\n  }\n\n  #processMap({ additionalProperties: valuesType }: MapSchema): TypeNode {\n    let valuesTypeNode: TypeNode;\n\n    if (typeof valuesType !== 'boolean') {\n      const nodes = new TypeSchemaProcessor(valuesType, this.#dependencies, this.#transferTypes).process();\n      valuesTypeNode = ts.factory.createUnionTypeNode(nodes);\n    } else {\n      valuesTypeNode = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);\n    }\n\n    return ts.factory.createTypeReferenceNode('Record', [\n      ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),\n      valuesTypeNode,\n    ]);\n  }\n\n  #processTypeArguments(schema: Schema): readonly TypeNode[] | undefined {\n    // Type arguments are processed recursively\n    return findTypeArguments(schema)\n      ?.allOf.map((s) => new TypeSchemaProcessor(s, this.#dependencies, this.#transferTypes).process())\n      .map((t) => ts.factory.createUnionTypeNode(t));\n  }\n\n  #processReference(schema: ReferenceSchema, typeArguments: readonly TypeNode[] | undefined): TypeNode {\n    const { imports, paths } = this.#dependencies;\n\n    const fullyQualifiedName = convertReferenceSchemaToFullyQualifiedName(schema);\n\n    if (this.#transferTypes.has(fullyQualifiedName)) {\n      return this.#transferTypes.get(fullyQualifiedName)!(typeArguments);\n    }\n\n    const specifier = convertReferenceSchemaToSpecifier(schema);\n    const path = paths.createRelativePath(convertFullyQualifiedNameToRelativePath(fullyQualifiedName));\n\n    const identifier = imports.default.getIdentifier(path) ?? imports.default.add(path, specifier, true);\n\n    return ts.factory.createTypeReferenceNode(identifier, typeArguments);\n  }\n}\n"],"version":3}