{"mappings":"AAqCA,OAAO,SAAS,kBAAkBA,QAA2C;AAC3E,QAAO,UAAU;AAClB;AAED,OAAO,SAAS,0BAA0BA,QAAmD;AAC3F,QAAO,WAAW;AACnB;AAED,OAAO,SAAS,0BAA0BA,QAAmD;AAC3F,QAAO,WAAW;AACnB;AAED,OAAO,SAAS,0BAA0BA,QAAmD;AAC3F,QAAO,WAAW;AACnB;AAED,OAAO,SAAS,wBAAwBA,QAAiD;AACvF,QAAO,SAAS;AACjB;AAED,OAAO,SAAS,iBAAiBA,QAA0C;AACzE,QACE,0BAA0B,OAAO,IACjC,0BAA0B,OAAO,IACjC,0BAA0B,OAAO,IACjC,wBAAwB,OAAO;AAElC;AAED,OAAO,SAAS,oBAAoBA,QAA6C;AAC/E,SAAQ,iBAAiB,OAAO;AACjC;AAED,OAAO,SAAS,2BAA2BA,QAAoD;AAC7F,QAAO,oBAAoB,OAAO,KAAK,kBAAkB,OAAO;AACjE;AAED,OAAO,SAAS,iBAAiBA,QAA0C;AACzE,SAAQ,kBAAkB,OAAO,MAAM,OAAO;AAC/C;AAED,OAAO,SAAS,gBAAgBC,QAA2C;AACzE,KAAI,0BAA0B,OAAO,EAAE;AACrC,SAAO,OAAO;CACf;AAED,KAAI,0BAA0B,OAAO,EAAE;AACrC,SAAO,OAAO;CACf;AAED,KAAI,0BAA0B,OAAO,EAAE;AACrC,SAAO,OAAO;CACf;AAED,QAAO,CAAC,OAAO,GAAI;AACpB;AAED,OAAO,SAAS,cAAcD,QAAuC;AACnE,QAAO,2BAA2B,OAAO,IAAI,OAAO,SAAS;AAC9D;AAED,OAAO,SAAS,gBAAgBA,QAAyC;AACvE,QAAO,2BAA2B,OAAO,IAAI,OAAO,SAAS;AAC9D;AAED,OAAO,SAAS,gBAAgBA,QAAyC;AACvE,QAAO,2BAA2B,OAAO,IAAI,OAAO,SAAS;AAC9D;AAED,OAAO,SAAS,eAAeA,QAAwC;AACrE,QAAO,2BAA2B,OAAO,IAAI,OAAO,SAAS;AAC9D;AAED,OAAO,SAAS,eAAeA,QAAwC;AACrE,QAAO,2BAA2B,OAAO,IAAI,OAAO,SAAS;AAC9D;AAED,OAAO,SAAS,eAAeA,QAAwC;AACrE,QAAO,2BAA2B,OAAO,IAAI,OAAO,SAAS;AAC9D;AAED,OAAO,SAAS,aAAaA,QAAsC;AACjE,QAAO,eAAe,OAAO,MAAM,OAAO;AAC3C;AAED,OAAO,SAAS,cAAcA,QAA6C;AACzE,QAAO,eAAe,OAAO,KAAK,OAAO;AAC1C;AAED,OAAO,SAAS,YAAYA,QAAqC;AAC/D,QAAO,cAAc,OAAO,MAAM,OAAO;AAC1C;AAED,OAAO,SAAS,2BAA2BE,MAAsB;AAC/D,QAAO,KAAK,UAAU,KAAK,YAAY,KAAK,SAAS,IAAI,GAAG,MAAM,IAAI,GAAG,GAAG,KAAK,OAAO;AACzF;AAED,OAAO,SAAS,kCAAkC,EAAE,MAAuB,EAAU;AACnF,QAAO,2BAA2B,KAAK;AACxC;AAED,MAAM,gCAAgC,wBAAwB;AAE9D,OAAO,SAAS,2CAA2C,EAAE,MAAuB,EAAU;AAC5F,QAAO,KAAK,UAAU,8BAA8B;AACrD;AAED,OAAO,SAAS,wCAAwCA,MAAsB;AAC5E,QAAO,KAAK,QAAQ,UAAU,IAAI;AACnC;AAED,OAAO,SAAS,6BAA6BC,QAAiC;AAC5E,QAAO,wCAAwC,2CAA2C,OAAO,CAAC;AACnG;AAED,OAAO,SAAS,iBACdC,SACA,EAAE,MAAuB,EACL;AACpB,KAAI,SAAS;AACX,OAAK,MAAM,CAAC,MAAM,OAAO,IAAI,OAAO,QAAQ,QAAQ,EAAE;AACpD,OAAI,KAAK,SAAS,KAAK,EAAE;AACvB,WAAO;GACR;EACF;CACF;AAED,QAAO;AACR","names":["schema: Schema","schema: ComposedSchema","name: string","schema: ReferenceSchema","schemas: OpenAPIV3.ComponentsObject['schemas']"],"sources":["/opt/agent/work/1af72d8adc613024/hilla/packages/ts/generator-core/src/Schema.ts"],"sourcesContent":["import type { OpenAPIV3 } from 'openapi-types';\n\nexport type Nullified<T, K extends keyof T> = T & Record<K, undefined>;\n\nexport type ReferenceSchema = OpenAPIV3.ReferenceObject;\nexport type ArraySchema = OpenAPIV3.ArraySchemaObject;\nexport type NonArraySchema = OpenAPIV3.NonArraySchemaObject;\nexport type RegularSchema = ArraySchema | NonArraySchema;\n\nexport type NullableSchema = Readonly<Required<Pick<RegularSchema, 'nullable'>>> & RegularSchema;\n\nexport type AnyOfRuleComposedSchema = Readonly<Required<Pick<RegularSchema, 'anyOf'>>> & RegularSchema;\nexport type AllOfRuleComposedSchema = Readonly<Required<Pick<RegularSchema, 'allOf'>>> & RegularSchema;\nexport type OneOfRuleComposedSchema = Readonly<Required<Pick<RegularSchema, 'oneOf'>>> & RegularSchema;\nexport type NotRuleComposedSchema = Readonly<Required<Pick<RegularSchema, 'not'>>> & RegularSchema;\nexport type ComposedSchema =\n  | AllOfRuleComposedSchema\n  | AnyOfRuleComposedSchema\n  | NotRuleComposedSchema\n  | OneOfRuleComposedSchema;\n\nexport type NonComposedRegularSchema = Readonly<Nullified<RegularSchema, 'allOf' | 'anyOf' | 'oneOf'>> & RegularSchema;\nexport type NonComposedSchema = NonComposedRegularSchema | ReferenceSchema;\n\nexport type BooleanSchema = NonComposedRegularSchema & Readonly<{ type: 'boolean' }>;\nexport type IntegerSchema = NonComposedRegularSchema & Readonly<{ type: 'integer' }>;\nexport type NumberSchema = NonComposedRegularSchema & Readonly<{ type: 'number' }>;\nexport type ObjectSchema = NonComposedRegularSchema & Readonly<{ type: 'object' }>;\nexport type StringSchema = NonComposedRegularSchema & Readonly<{ type: 'string' }>;\n\nexport type EnumSchema = Readonly<Required<Pick<StringSchema, 'enum'>>> & StringSchema;\nexport type EmptyObjectSchema = ObjectSchema & Readonly<Nullified<ObjectSchema, 'properties'>>;\nexport type NonEmptyObjectSchema = ObjectSchema & Readonly<Required<Pick<ObjectSchema, 'properties'>>>;\nexport type MapSchema = EmptyObjectSchema & Readonly<Required<Pick<ObjectSchema, 'additionalProperties'>>>;\n\nexport type Schema = ReferenceSchema | RegularSchema;\n\nexport function isReferenceSchema(schema: Schema): schema is ReferenceSchema {\n  return '$ref' in schema;\n}\n\nexport function isAnyOfRuleComposedSchema(schema: Schema): schema is AnyOfRuleComposedSchema {\n  return 'anyOf' in schema;\n}\n\nexport function isAllOfRuleComposedSchema(schema: Schema): schema is AllOfRuleComposedSchema {\n  return 'allOf' in schema;\n}\n\nexport function isOneOfRuleComposedSchema(schema: Schema): schema is OneOfRuleComposedSchema {\n  return 'oneOf' in schema;\n}\n\nexport function isNotRuleComposedSchema(schema: Schema): schema is NotRuleComposedSchema {\n  return 'not' in schema;\n}\n\nexport function isComposedSchema(schema: Schema): schema is ComposedSchema {\n  return (\n    isAnyOfRuleComposedSchema(schema) ||\n    isAllOfRuleComposedSchema(schema) ||\n    isOneOfRuleComposedSchema(schema) ||\n    isNotRuleComposedSchema(schema)\n  );\n}\n\nexport function isNonComposedSchema(schema: Schema): schema is NonComposedSchema {\n  return !isComposedSchema(schema);\n}\n\nexport function isNonComposedRegularSchema(schema: Schema): schema is NonComposedRegularSchema {\n  return isNonComposedSchema(schema) && !isReferenceSchema(schema);\n}\n\nexport function isNullableSchema(schema: Schema): schema is NullableSchema {\n  return !isReferenceSchema(schema) && !!schema.nullable;\n}\n\nexport function decomposeSchema(schema: ComposedSchema): readonly Schema[] {\n  if (isAnyOfRuleComposedSchema(schema)) {\n    return schema.anyOf;\n  }\n\n  if (isAllOfRuleComposedSchema(schema)) {\n    return schema.allOf;\n  }\n\n  if (isOneOfRuleComposedSchema(schema)) {\n    return schema.oneOf;\n  }\n\n  return [schema.not];\n}\n\nexport function isArraySchema(schema: Schema): schema is ArraySchema {\n  return isNonComposedRegularSchema(schema) && schema.type === 'array';\n}\n\nexport function isBooleanSchema(schema: Schema): schema is BooleanSchema {\n  return isNonComposedRegularSchema(schema) && schema.type === 'boolean';\n}\n\nexport function isIntegerSchema(schema: Schema): schema is IntegerSchema {\n  return isNonComposedRegularSchema(schema) && schema.type === 'integer';\n}\n\nexport function isNumberSchema(schema: Schema): schema is NumberSchema {\n  return isNonComposedRegularSchema(schema) && schema.type === 'number';\n}\n\nexport function isObjectSchema(schema: Schema): schema is ObjectSchema {\n  return isNonComposedRegularSchema(schema) && schema.type === 'object';\n}\n\nexport function isStringSchema(schema: Schema): schema is StringSchema {\n  return isNonComposedRegularSchema(schema) && schema.type === 'string';\n}\n\nexport function isEnumSchema(schema: Schema): schema is EnumSchema {\n  return isStringSchema(schema) && !!schema.enum;\n}\n\nexport function isEmptyObject(schema: Schema): schema is EmptyObjectSchema {\n  return isObjectSchema(schema) && !schema.properties;\n}\n\nexport function isMapSchema(schema: Schema): schema is MapSchema {\n  return isEmptyObject(schema) && !!schema.additionalProperties;\n}\n\nexport function simplifyFullyQualifiedName(name: string): string {\n  return name.substring(name.lastIndexOf(name.includes('$') ? '$' : '.') + 1, name.length);\n}\n\nexport function convertReferenceSchemaToSpecifier({ $ref }: ReferenceSchema): string {\n  return simplifyFullyQualifiedName($ref);\n}\n\nconst COMPONENTS_SCHEMAS_REF_LENGTH = '#/components/schemas/'.length;\n\nexport function convertReferenceSchemaToFullyQualifiedName({ $ref }: ReferenceSchema): string {\n  return $ref.substring(COMPONENTS_SCHEMAS_REF_LENGTH);\n}\n\nexport function convertFullyQualifiedNameToRelativePath(name: string): string {\n  return name.replace(/[$.]/gu, '/');\n}\n\nexport function convertReferenceSchemaToPath(schema: ReferenceSchema): string {\n  return convertFullyQualifiedNameToRelativePath(convertReferenceSchemaToFullyQualifiedName(schema));\n}\n\nexport function resolveReference(\n  schemas: OpenAPIV3.ComponentsObject['schemas'],\n  { $ref }: ReferenceSchema,\n): Schema | undefined {\n  if (schemas) {\n    for (const [name, schema] of Object.entries(schemas)) {\n      if ($ref.includes(name)) {\n        return schema;\n      }\n    }\n  }\n\n  return undefined;\n}\n"],"version":3}