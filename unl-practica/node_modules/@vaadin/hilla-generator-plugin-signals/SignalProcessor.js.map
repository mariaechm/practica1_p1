{"mappings":"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","names":["#dependencyManager","#owner","#service","#methods","#sourceFile","service: string","methods: Map<string, string>","sourceFile: SourceFile","owner: Plugin","functionParams: Map<string, ts.ParameterDeclaration[]>","#replaceSignalImport","#createDefaultValue","signalId: ts.Identifier","functionDeclaration: FunctionDeclaration","defaultValue: {\n      defaultValueExpression: ts.Expression | ts.Identifier;\n      defaultValueParam: ts.ParameterDeclaration | undefined;\n      genericReturnType: ts.TypeNode | undefined;\n    }","#getDefaultValueType","#createDefaultValueParameter","#createEmptyValueExpression","node: ts.Node","defaultValueType: ts.TypeNode","#isDefaultValueTypeNullable","defaultValueType: ts.UnionTypeNode","#determineModelImportUniqueIdentifier","returnTypeNode: ts.UnionTypeNode","#extractModelNameFromTypeNode","#getExistingEntityModelUniqueIdentifier","#addModelImport","modelName: string","entityName: string | undefined","modelName: string | undefined","modelNameUniqueId: ts.Identifier | undefined","#addObjectModelImport","entityName: string","modelNameUniqueId: ts.Identifier","method: FunctionDeclaration"],"sources":["/opt/agent/work/1af72d8adc613024/hilla/packages/ts/generator-plugin-signals/src/SignalProcessor.ts"],"sourcesContent":["import type Plugin from '@vaadin/hilla-generator-core/Plugin.js';\nimport { template, transform, traverse } from '@vaadin/hilla-generator-utils/ast.js';\nimport createFullyUniqueIdentifier from '@vaadin/hilla-generator-utils/createFullyUniqueIdentifier.js';\nimport createSourceFile from '@vaadin/hilla-generator-utils/createSourceFile.js';\nimport DependencyManager from '@vaadin/hilla-generator-utils/dependencies/DependencyManager.js';\nimport PathManager from '@vaadin/hilla-generator-utils/dependencies/PathManager.js';\nimport ts, { type FunctionDeclaration, type Identifier, type SourceFile } from 'typescript';\n\nconst HILLA_REACT_SIGNALS = '@vaadin/hilla-react-signals';\n\nconst CONNECT_CLIENT = '$CONNECT_CLIENT$';\nconst METHOD_NAME = '$METHOD_NAME$';\nconst SIGNAL = '$SIGNAL$';\nconst RETURN_TYPE = '$RETURN_TYPE$';\nconst INITIAL_VALUE = '$INITIAL_VALUE$';\n\nconst signals = ['NumberSignal', 'ValueSignal', 'ListSignal'];\nconst genericSignals = ['ValueSignal', 'ListSignal'];\nconst collectionSignals = ['ListSignal'];\n\nconst primitiveModels = Object.freeze(\n  new Map<ts.SyntaxKind, string>([\n    [ts.SyntaxKind.StringKeyword, 'StringModel'],\n    [ts.SyntaxKind.NumberKeyword, 'NumberModel'],\n    [ts.SyntaxKind.BooleanKeyword, 'BooleanModel'],\n    [ts.SyntaxKind.ArrayType, 'ArrayModel'],\n  ]),\n);\n\nexport default class SignalProcessor {\n  readonly #dependencyManager: DependencyManager;\n  readonly #owner: Plugin;\n  readonly #service: string;\n  readonly #methods: Map<string, string>;\n  readonly #sourceFile: SourceFile;\n\n  constructor(service: string, methods: Map<string, string>, sourceFile: SourceFile, owner: Plugin) {\n    this.#service = service;\n    this.#methods = methods;\n    this.#sourceFile = sourceFile;\n    this.#owner = owner;\n    this.#dependencyManager = new DependencyManager(new PathManager({ extension: '.js' }));\n    this.#dependencyManager.imports.fromCode(this.#sourceFile);\n  }\n\n  process(): SourceFile {\n    this.#owner.logger.debug(`Processing signals: ${this.#service}`);\n    const { imports } = this.#dependencyManager;\n\n    const [, connectClientId] = imports.default.iter().find(([path]) => path.includes('connect-client'))!;\n\n    const initTypeId = imports.named.getIdentifier('@vaadin/hilla-frontend', 'EndpointRequestInit');\n    let initTypeUsageCount = 0;\n    const functionParams: Map<string, ts.ParameterDeclaration[]> = new Map<string, ts.ParameterDeclaration[]>();\n\n    const [file] = ts.transform<SourceFile>(this.#sourceFile, [\n      transform((tsNode) => {\n        if (ts.isFunctionDeclaration(tsNode) && tsNode.name && this.#methods.has(tsNode.name.text)) {\n          const signalId = this.#replaceSignalImport(tsNode);\n          const filteredParams = tsNode.parameters.filter(\n            (p) => !p.type || !ts.isTypeReferenceNode(p.type) || p.type.typeName !== initTypeId,\n          );\n          // `filteredParams` can be altered after, need to store the param names now\n          const paramNames = filteredParams.map((p) => (p.name as ts.Identifier).text).join(', ');\n          const isCollectionSignal = collectionSignals.includes(signalId.text);\n\n          const { defaultValueExpression, defaultValueParam, genericReturnType } = this.#createDefaultValue(\n            signalId,\n            tsNode,\n          );\n          if (defaultValueParam) {\n            filteredParams.push(defaultValueParam);\n          }\n\n          const returnType = genericReturnType ?? signalId;\n          if (filteredParams.length > 0) {\n            functionParams.set(tsNode.name.text, filteredParams);\n          }\n          return template(\n            `function ${METHOD_NAME}(): ${RETURN_TYPE} {\n  return new ${SIGNAL}(${\n    isCollectionSignal ? '' : `${INITIAL_VALUE}, `\n  }{ client: ${CONNECT_CLIENT}, endpoint: '${this.#service}', method: '${tsNode.name.text}'${\n    paramNames.length ? `, params: { ${paramNames} }` : ''\n  } });\n}`,\n            (statements) => statements,\n            [\n              transform((node) => (ts.isIdentifier(node) && node.text === METHOD_NAME ? tsNode.name : node)),\n              transform((node) => (ts.isIdentifier(node) && node.text === SIGNAL ? signalId : node)),\n              transform((node) => (ts.isIdentifier(node) && node.text === RETURN_TYPE ? returnType : node)),\n              transform((node) => (ts.isIdentifier(node) && node.text === CONNECT_CLIENT ? connectClientId : node)),\n              transform((node) =>\n                ts.isIdentifier(node) && node.text === INITIAL_VALUE ? defaultValueExpression : node,\n              ),\n            ],\n          );\n        }\n        return tsNode;\n      }),\n      transform((tsNode) => {\n        if (\n          ts.isFunctionDeclaration(tsNode) &&\n          tsNode.name &&\n          this.#methods.has(tsNode.name.text) &&\n          functionParams.has(tsNode.name.text)\n        ) {\n          return ts.factory.updateFunctionDeclaration(\n            tsNode,\n            tsNode.modifiers,\n            tsNode.asteriskToken,\n            tsNode.name,\n            tsNode.typeParameters,\n            functionParams.get(tsNode.name.text)!,\n            tsNode.type,\n            tsNode.body,\n          );\n        }\n        return tsNode;\n      }),\n      transform((tsNode) => {\n        if (ts.isFunctionDeclaration(tsNode)) {\n          if (\n            !(tsNode.name && this.#methods.has(tsNode.name.text)) &&\n            tsNode.parameters.some((p) => p.type && ts.isTypeReferenceNode(p.type) && p.type.typeName === initTypeId)\n          ) {\n            initTypeUsageCount += 1;\n          }\n        }\n        return tsNode;\n      }),\n    ]).transformed;\n\n    if (initTypeUsageCount === 0) {\n      imports.named.remove('@vaadin/hilla-frontend', 'EndpointRequestInit');\n    }\n\n    return createSourceFile(\n      [\n        ...this.#dependencyManager.imports.toCode(),\n        ...file.statements.filter((statement) => !ts.isImportDeclaration(statement)),\n      ],\n      file.fileName,\n    );\n  }\n\n  #createDefaultValue(signalId: ts.Identifier, functionDeclaration: FunctionDeclaration) {\n    const defaultValue: {\n      defaultValueExpression: ts.Expression | ts.Identifier;\n      defaultValueParam: ts.ParameterDeclaration | undefined;\n      genericReturnType: ts.TypeNode | undefined;\n    } = {\n      defaultValueExpression: signalId.text.startsWith('NumberSignal')\n        ? ts.factory.createNumericLiteral('0')\n        : ts.factory.createIdentifier('undefined'),\n      defaultValueParam: undefined,\n      genericReturnType: undefined,\n    };\n\n    if (!genericSignals.includes(signalId.text)) {\n      return defaultValue;\n    }\n\n    [defaultValue.genericReturnType] = (functionDeclaration.type as ts.TypeReferenceNode).typeArguments!;\n\n    if (collectionSignals.includes(signalId.text)) {\n      return defaultValue;\n    }\n\n    const defaultValueType = SignalProcessor.#getDefaultValueType(defaultValue.genericReturnType);\n    if (!defaultValueType) {\n      return defaultValue;\n    }\n\n    defaultValue.defaultValueParam = SignalProcessor.#createDefaultValueParameter(defaultValueType);\n    const emptyValueExpression = this.#createEmptyValueExpression(defaultValueType);\n\n    defaultValue.defaultValueExpression = ts.factory.createBinaryExpression(\n      ts.factory.createPropertyAccessChain(\n        ts.factory.createIdentifier('options'),\n        ts.factory.createToken(ts.SyntaxKind.QuestionDotToken),\n        ts.factory.createIdentifier('defaultValue'),\n      ),\n      ts.factory.createToken(ts.SyntaxKind.QuestionQuestionToken),\n      emptyValueExpression,\n    );\n\n    return defaultValue;\n  }\n\n  static #getDefaultValueType(node: ts.Node) {\n    if (\n      ts.isUnionTypeNode(node) &&\n      node.types.length &&\n      ts.isTypeReferenceNode(node.types[0]) &&\n      node.types[0].typeArguments?.length === 1 &&\n      ts.isUnionTypeNode(node.types[0].typeArguments[0])\n    ) {\n      return node.types[0].typeArguments[0];\n    }\n    return undefined;\n  }\n\n  static #createDefaultValueParameter(defaultValueType: ts.TypeNode) {\n    const paramType = ts.factory.createTypeLiteralNode([\n      ts.factory.createPropertySignature(\n        undefined,\n        ts.factory.createIdentifier('defaultValue'),\n        undefined,\n        defaultValueType,\n      ),\n    ]);\n\n    return ts.factory.createParameterDeclaration(\n      undefined,\n      undefined,\n      'options',\n      ts.factory.createToken(ts.SyntaxKind.QuestionToken),\n      paramType,\n    );\n  }\n\n  static #isDefaultValueTypeNullable(defaultValueType: ts.TypeNode) {\n    return (\n      ts.isUnionTypeNode(defaultValueType) &&\n      defaultValueType.types.length &&\n      defaultValueType.types.length > 1 &&\n      defaultValueType.types.map((t) => t.kind).includes(ts.SyntaxKind.UndefinedKeyword)\n    );\n  }\n\n  #createEmptyValueExpression(defaultValueType: ts.UnionTypeNode) {\n    if (SignalProcessor.#isDefaultValueTypeNullable(defaultValueType)) {\n      return ts.factory.createIdentifier('undefined');\n    }\n    const importedModelUniqueId = this.#determineModelImportUniqueIdentifier(defaultValueType);\n    return ts.factory.createCallExpression(\n      ts.factory.createPropertyAccessExpression(importedModelUniqueId, 'createEmptyValue'),\n      undefined,\n      [],\n    );\n  }\n\n  #determineModelImportUniqueIdentifier(returnTypeNode: ts.UnionTypeNode) {\n    let modelName = primitiveModels.get(returnTypeNode.types[0].kind);\n    let entityName;\n    if (modelName === undefined) {\n      const { entityName: e, modelName: m } = SignalProcessor.#extractModelNameFromTypeNode(returnTypeNode);\n      modelName = m;\n      entityName = e;\n    }\n    const modelImportUniqueId =\n      this.#getExistingEntityModelUniqueIdentifier(modelName) ?? createFullyUniqueIdentifier(modelName);\n\n    this.#addModelImport(entityName, modelName, modelImportUniqueId);\n    return modelImportUniqueId;\n  }\n\n  static #extractModelNameFromTypeNode(returnTypeNode: ts.UnionTypeNode) {\n    if (ts.isTypeReferenceNode(returnTypeNode.types[0])) {\n      const typeIdentifier = returnTypeNode.types[0].typeName;\n      if (ts.isIdentifier(typeIdentifier)) {\n        const entityName = typeIdentifier.text;\n        const modelName = `${entityName}Model`;\n        return { entityName, modelName };\n      }\n    }\n    throw new Error('Unsupported type reference node');\n  }\n\n  #getExistingEntityModelUniqueIdentifier(modelName: string) {\n    const { imports } = this.#dependencyManager;\n    return (\n      imports.named.getIdentifier('@vaadin/hilla-lit-form', modelName) ??\n      imports.default.iter().find(([path]) => path.endsWith(`/${modelName}.js`))?.[1]\n    );\n  }\n\n  #addModelImport(\n    entityName: string | undefined,\n    modelName: string | undefined,\n    modelNameUniqueId: ts.Identifier | undefined,\n  ) {\n    if (modelName) {\n      if (primitiveModels.values().find((primitiveModel) => primitiveModel === modelName)) {\n        const { imports } = this.#dependencyManager;\n        const importedModel = imports.named.getIdentifier('@vaadin/hilla-lit-form', modelName);\n        if (importedModel === undefined) {\n          imports.named.add('@vaadin/hilla-lit-form', modelName, false, modelNameUniqueId);\n        }\n      } else {\n        this.#addObjectModelImport(entityName!, modelName, modelNameUniqueId!);\n      }\n    }\n  }\n\n  #addObjectModelImport(entityName: string, modelName: string, modelNameUniqueId: ts.Identifier) {\n    const { imports } = this.#dependencyManager;\n    const entityImport = imports.default\n      .iter()\n      .map(([path]) => path)\n      .find((path) => path.startsWith('./') && path.endsWith(`/${entityName}.js`));\n    if (entityImport) {\n      const entityModelImportPath = entityImport.replace(`/${entityName}.js`, `/${modelName}.js`);\n      const importedModel = imports.default.paths().find((path) => path === entityModelImportPath);\n      if (importedModel === undefined) {\n        imports.default.add(entityModelImportPath, modelName, false, modelNameUniqueId);\n      }\n    }\n  }\n\n  #replaceSignalImport(method: FunctionDeclaration): Identifier {\n    const { imports } = this.#dependencyManager;\n\n    if (method.type) {\n      const type = traverse(method.type, (node) =>\n        ts.isIdentifier(node) && signals.includes(node.text) ? node : undefined,\n      );\n\n      if (type) {\n        const signalId = imports.named.getIdentifier(HILLA_REACT_SIGNALS, type.text);\n\n        if (signalId) {\n          return signalId;\n        }\n\n        const result = imports.default.iter().find(([_p, id]) => id.text === type.text);\n\n        if (result) {\n          const [path] = result;\n          imports.default.remove(path);\n          return imports.named.add(HILLA_REACT_SIGNALS, type.text, false, type);\n        }\n      }\n    }\n\n    throw new Error('Signal type not found');\n  }\n}\n"],"version":3}