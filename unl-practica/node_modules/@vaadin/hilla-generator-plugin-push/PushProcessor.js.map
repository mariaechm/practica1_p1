{"mappings":"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","names":["#dependencies","#operations","#source","#subscriptionId","source: ts.SourceFile","operations: EndpointOperations","#updateFunction","#removeInitImport","updatedStatements: readonly ts.Statement[]","#doesInitParameterExist","parameters: ts.NodeArray<ts.ParameterDeclaration>","importStatement: ts.ImportDeclaration","declaration: ts.FunctionDeclaration","#replacePromiseType","#updateFunctionBody","doesInitParameterExist: boolean"],"sources":["/opt/agent/work/1af72d8adc613024/hilla/packages/ts/generator-plugin-push/src/PushProcessor.ts"],"sourcesContent":["import createSourceFile from '@vaadin/hilla-generator-utils/createSourceFile.js';\nimport DependencyManager from '@vaadin/hilla-generator-utils/dependencies/DependencyManager.js';\nimport PathManager from '@vaadin/hilla-generator-utils/dependencies/PathManager.js';\nimport memoize from '@vaadin/hilla-generator-utils/memoize.js';\nimport ts from 'typescript';\n\nconst initParameterTypeName = 'EndpointRequestInit';\n\nexport type EndpointOperations = {\n  methodsToPatch: string[];\n  removeInitImport: boolean;\n};\n\nexport class PushProcessor {\n  readonly #dependencies = new DependencyManager(new PathManager({ extension: '.js' }));\n  readonly #operations: EndpointOperations;\n  readonly #source: ts.SourceFile;\n  readonly #subscriptionId: () => ts.Identifier;\n\n  constructor(source: ts.SourceFile, operations: EndpointOperations) {\n    this.#operations = operations;\n    this.#source = source;\n\n    const { imports, paths } = this.#dependencies;\n\n    this.#dependencies.imports.fromCode(source);\n    this.#subscriptionId = memoize(() =>\n      imports.named.add(paths.createBareModulePath('@vaadin/hilla-frontend', false), 'Subscription'),\n    );\n  }\n\n  process(): ts.SourceFile {\n    const otherStatements = this.#source.statements\n      .filter((statement) => !ts.isImportDeclaration(statement))\n      .map((statement) => {\n        if (ts.isFunctionDeclaration(statement)) {\n          const functionName = statement.name?.text;\n\n          // Checks if the method is in the list of methods to patch\n          if (functionName && this.#operations.methodsToPatch.includes(functionName)) {\n            return this.#updateFunction(statement);\n          }\n        }\n\n        return statement;\n      });\n\n    let importStatements = this.#dependencies.imports.toCode();\n\n    if (this.#operations.removeInitImport) {\n      const importHillaFrontend = importStatements.find(\n        (statement) =>\n          ts.isImportDeclaration(statement) &&\n          (statement.moduleSpecifier as ts.StringLiteral).text === '@vaadin/hilla-frontend',\n      );\n\n      if (importHillaFrontend) {\n        const updatedImportStatement = PushProcessor.#removeInitImport(importHillaFrontend as ts.ImportDeclaration);\n\n        if (updatedImportStatement) {\n          importStatements = importStatements.map((statement) => {\n            if (statement === importHillaFrontend) {\n              return updatedImportStatement;\n            }\n\n            return statement;\n          });\n        }\n      }\n    }\n\n    const updatedStatements: readonly ts.Statement[] = [...importStatements, ...otherStatements];\n\n    return createSourceFile(updatedStatements, this.#source.fileName);\n  }\n\n  static #doesInitParameterExist(parameters: ts.NodeArray<ts.ParameterDeclaration>): boolean {\n    const last = parameters[parameters.length - 1];\n    const lastType = last.type as ts.TypeReferenceNode;\n    const lastTypeName = lastType.typeName as ts.Identifier;\n\n    return lastTypeName.text === initParameterTypeName;\n  }\n\n  static #removeInitImport(importStatement: ts.ImportDeclaration): ts.Statement | undefined {\n    const namedImports = importStatement.importClause?.namedBindings;\n    if (namedImports && ts.isNamedImports(namedImports)) {\n      const updatedElements = namedImports.elements.filter((element) => element.name.text !== 'EndpointRequestInit');\n\n      const updatedImportClause = ts.factory.updateImportClause(\n        importStatement.importClause,\n        false, // FIXME: could be true, but it is false for regular endpoint calls, so sticking to that for now\n        undefined,\n        ts.factory.createNamedImports(updatedElements),\n      );\n\n      return ts.factory.updateImportDeclaration(\n        importStatement,\n        undefined,\n        updatedImportClause,\n        importStatement.moduleSpecifier,\n        undefined,\n      );\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Replace returned `Promise<Array<T>>` by the `Subscription<T>` type\n   * @param declaration -\n   */\n  #replacePromiseType(declaration: ts.FunctionDeclaration) {\n    const [promiseType] = (declaration.type as ts.TypeReferenceNode).typeArguments!;\n    const promiseArray = (ts.isUnionTypeNode(promiseType) ? promiseType.types[0] : promiseType) as ts.TypeReferenceNode;\n\n    return ts.factory.createTypeReferenceNode(this.#subscriptionId(), promiseArray.typeArguments);\n  }\n\n  #updateFunction(declaration: ts.FunctionDeclaration): ts.FunctionDeclaration {\n    const { parameters } = declaration;\n    const doesInitParameterExist = PushProcessor.#doesInitParameterExist(parameters);\n\n    return ts.factory.createFunctionDeclaration(\n      undefined, // no async\n      declaration.asteriskToken,\n      declaration.name,\n      declaration.typeParameters,\n      // Remove the `init` parameter\n      doesInitParameterExist ? parameters.slice(0, -1) : parameters,\n      this.#replacePromiseType(declaration),\n      PushProcessor.#updateFunctionBody(declaration, doesInitParameterExist),\n    );\n  }\n\n  static #updateFunctionBody(declaration: ts.FunctionDeclaration, doesInitParameterExist: boolean): ts.Block {\n    const returnStatement = declaration.body!.statements[0] as ts.ReturnStatement;\n    const { arguments: args, expression, typeArguments } = returnStatement.expression! as ts.CallExpression;\n    const call = expression as ts.PropertyAccessExpression;\n\n    return ts.factory.createBlock([\n      ts.factory.createReturnStatement(\n        ts.factory.createCallExpression(\n          ts.factory.createPropertyAccessExpression(\n            call.expression,\n            // `subscribe` instead of `call`\n            ts.factory.createIdentifier('subscribe'),\n          ),\n          typeArguments,\n          // remove the `init` parameter\n          doesInitParameterExist ? args.slice(0, -1) : args,\n        ),\n      ),\n    ]);\n  }\n}\n"],"version":3}