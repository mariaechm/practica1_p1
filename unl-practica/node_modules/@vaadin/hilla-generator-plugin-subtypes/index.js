import Plugin from "@vaadin/hilla-generator-core/Plugin.js";
import { isReferenceSchema, convertFullyQualifiedNameToRelativePath } from "@vaadin/hilla-generator-core/Schema.js";
import { ModelFixProcessor } from "./ModelFixProcessor.js";
import { SubTypesProcessor } from "./SubTypesProcessor.js";
import { TypeFixProcessor } from "./TypeFixProcessor.js";
export default class SubTypesPlugin extends Plugin {
	get path() {
		return import.meta.url;
	}
	async execute(storage) {
		const { api, sources } = storage;
		const components = api.components?.schemas;
		if (!components) {
			return;
		}
		Object.entries(components).forEach(([baseKey, baseComponent]) => {
			if ("oneOf" in baseComponent && Array.isArray(baseComponent.oneOf) && baseComponent.oneOf.every((schema) => isReferenceSchema(schema))) {
				const fn = `${convertFullyQualifiedNameToRelativePath(baseKey)}.ts`;
				const source = sources.find(({ fileName }) => fileName === fn);
				const newSource = new SubTypesProcessor(baseKey, source, baseComponent.oneOf).process();
				sources.splice(sources.indexOf(source), 1, newSource);
				baseComponent.oneOf.forEach((schema) => {
					if ("$ref" in schema) {
						const path = schema.$ref;
						Object.entries(components).forEach(([subKey, subComponent]) => {
							if ("anyOf" in subComponent && subKey === path.substring("#/components/schemas/".length)) {
								subComponent.anyOf?.forEach((s) => {
									if ("properties" in s && "@type" in s.properties && "example" in s.properties["@type"]) {
										const typeValue = s.properties["@type"].example;
										const subFn = `${convertFullyQualifiedNameToRelativePath(subKey)}.ts`;
										const subSource = sources.find(({ fileName }) => fileName === subFn);
										const fixedSource = new TypeFixProcessor(subSource, typeValue).process();
										sources.splice(sources.indexOf(subSource), 1, fixedSource);
										const modelFn = `${convertFullyQualifiedNameToRelativePath(subKey)}Model.ts`;
										const modelSource = sources.find(({ fileName }) => fileName === modelFn);
										const fixedModelSource = new ModelFixProcessor(modelSource).process();
										sources.splice(sources.indexOf(modelSource), 1, fixedModelSource);
									}
								});
							}
						});
					}
				});
				const unionFn = `${convertFullyQualifiedNameToRelativePath(baseKey)}Model.ts`;
				const unionSource = sources.find(({ fileName }) => fileName === unionFn);
				sources.splice(sources.indexOf(unionSource), 1);
			}
		});
	}
}
//# sourceMappingURL=./index.js.map