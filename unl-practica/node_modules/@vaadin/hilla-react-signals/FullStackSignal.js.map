{"version":3,"file":"FullStackSignal.js","sourceRoot":"","sources":["src/FullStackSignal.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ActionOnLostSubscription, ConnectClient, Subscription } from '@vaadin/hilla-frontend';\nimport { nanoid } from 'nanoid';\nimport { computed, signal, Signal } from './core.js';\nimport { createSetStateEvent, type StateEvent } from './events.js';\n\nconst ENDPOINT = 'SignalsHandler';\n\n/**\n * A return type for signal operations that exposes a `result` property of type\n * `Promise`, that resolves when the operation is completed. It allows defining\n * callbacks to be run after the operation is completed, or error handling when\n * the operation fails.\n *\n * @example\n * ```ts\n * const sharedName = NameService.sharedName({ defaultValue: '' });\n * sharedName.replace('John').result\n *    .then(() => console.log('Name updated successfully'))\n *    .catch((error) => console.error('Failed to update the name:', error));\n * ```\n */\nexport interface Operation {\n  result: Promise<void>;\n}\n\n/**\n * An abstraction of a signal that tracks the number of subscribers, and calls\n * the provided `onSubscribe` and `onUnsubscribe` callbacks for the first\n * subscription and the last unsubscription, respectively.\n * @internal\n */\nexport abstract class DependencyTrackingSignal<T> extends Signal<T> {\n  readonly #onFirstSubscribe: () => void;\n  readonly #onLastUnsubscribe: () => void;\n\n  // -1 means to ignore the first subscription that is created internally in the\n  // FullStackSignal constructor.\n  #subscribeCount = -1;\n\n  protected constructor(value: T | undefined, onFirstSubscribe: () => void, onLastUnsubscribe: () => void) {\n    super(value);\n    this.#onFirstSubscribe = onFirstSubscribe;\n    this.#onLastUnsubscribe = onLastUnsubscribe;\n  }\n\n  protected override S(node: unknown): void {\n    super.S(node);\n    if (this.#subscribeCount === 0) {\n      this.#onFirstSubscribe();\n    }\n    this.#subscribeCount += 1;\n  }\n\n  protected override U(node: unknown): void {\n    super.U(node);\n    this.#subscribeCount -= 1;\n    if (this.#subscribeCount === 0) {\n      this.#onLastUnsubscribe();\n    }\n  }\n}\n\n/**\n * An object that describes a data object to connect to the signal provider\n * service.\n */\nexport type ServerConnectionConfig = Readonly<{\n  /**\n   * The client instance to be used for communication.\n   */\n  client: ConnectClient;\n\n  /**\n   * The name of the signal provider service endpoint.\n   */\n  endpoint: string;\n\n  /**\n   * The name of the signal provider service method.\n   */\n  method: string;\n\n  /**\n   * Optional object with method call arguments to be sent to the endpoint\n   * method that provides the signal when subscribing to it.\n   */\n  params?: Record<string, unknown>;\n\n  /**\n   * The unique identifier of the parent signal in the client.\n   */\n  parentClientSignalId?: string;\n}>;\n\n/**\n * A server connection manager.\n */\nclass ServerConnection {\n  readonly #id: string;\n  readonly config: ServerConnectionConfig;\n  #subscription?: Subscription<StateEvent>;\n\n  constructor(id: string, config: ServerConnectionConfig) {\n    this.config = config;\n    this.#id = id;\n  }\n\n  get subscription() {\n    return this.#subscription;\n  }\n\n  connect() {\n    const { client, endpoint, method, params, parentClientSignalId } = this.config;\n\n    this.#subscription ??= client.subscribe(ENDPOINT, 'subscribe', {\n      providerEndpoint: endpoint,\n      providerMethod: method,\n      clientSignalId: this.#id,\n      params,\n      parentClientSignalId,\n    });\n\n    return this.#subscription;\n  }\n\n  async update(event: StateEvent): Promise<void> {\n    const onTheFly = !this.#subscription;\n\n    if (onTheFly) {\n      this.connect();\n    }\n\n    await this.config.client.call(ENDPOINT, 'update', {\n      clientSignalId: this.#id,\n      event,\n    });\n\n    if (onTheFly) {\n      this.disconnect();\n    }\n  }\n\n  disconnect() {\n    this.#subscription?.cancel();\n    this.#subscription = undefined;\n  }\n}\n\nexport const $update = Symbol('update');\nexport const $processServerResponse = Symbol('processServerResponse');\nexport const $setValueQuietly = Symbol('setValueQuietly');\nexport const $resolveOperation = Symbol('resolveOperation');\nexport const $createOperation = Symbol('createOperation');\n\n/**\n * A signal that holds a shared value. Each change to the value is propagated to\n * the server-side signal provider. At the same time, each change received from\n * the server-side signal provider is propagated to the local signal and it's\n * subscribers.\n *\n * @internal\n */\nexport abstract class FullStackSignal<T> extends DependencyTrackingSignal<T> {\n  /**\n   * The unique identifier of the signal necessary to communicate with the\n   * server.\n   */\n  readonly id: string;\n\n  /**\n   * The server connection manager.\n   */\n  readonly server: ServerConnection;\n\n  /**\n   * Defines whether the signal is currently awaits a server-side response.\n   */\n  readonly pending = computed(() => this.#pending.value);\n\n  /**\n   * Defines whether the signal has an error.\n   */\n  readonly error = computed(() => this.#error.value);\n\n  readonly #pending = signal(false);\n  readonly #error = signal<Error | undefined>(undefined);\n\n  // Paused at the very start to prevent the signal from sending the initial\n  // value to the server.\n  #paused = true;\n\n  constructor(value: T | undefined, config: ServerConnectionConfig, id?: string) {\n    super(\n      value,\n      () => this.#connect(),\n      () => this.#disconnect(),\n    );\n    this.id = id ?? nanoid();\n    this.server = new ServerConnection(this.id, config);\n\n    this.subscribe((v) => {\n      if (!this.#paused) {\n        this.#pending.value = true;\n        this.#error.value = undefined;\n        // For internal signals, the provided non-null to the constructor should\n        // be used along with the parent client side signal id when sending the\n        // set event to the server. For internal signals this combination is\n        // needed for addressing the correct parent/child signal instances on\n        // the server. For a standalone signal, both of them should be passed in\n        // as undefined:\n        const signalId = config.parentClientSignalId !== undefined ? this.id : undefined;\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this[$update](createSetStateEvent(v, signalId, config.parentClientSignalId));\n      }\n    });\n\n    this.#paused = false;\n  }\n\n  // stores the promise handlers associated to operations\n  readonly #operationPromises = new Map<\n    string,\n    {\n      resolve(value: PromiseLike<void> | void): void;\n      reject(reason?: any): void;\n    }\n  >();\n\n  // creates the object to be returned by operations to allow defining callbacks\n  protected [$createOperation]({ id, promise }: { id?: string; promise?: Promise<void> }): Operation {\n    const thens = this.#operationPromises;\n    const promises: Array<Promise<void>> = [];\n\n    if (promise) {\n      // Add the provided promise to the list of promises\n      promises.push(promise);\n    }\n\n    if (id) {\n      // Create a promise to be associated to the provided id\n      promises.push(\n        new Promise<void>((resolve, reject) => {\n          thens.set(id, { resolve, reject });\n        }),\n      );\n    }\n\n    if (promises.length === 0) {\n      // If no promises were added, return a resolved promise\n      promises.push(Promise.resolve());\n    }\n\n    return {\n      result: Promise.allSettled(promises).then((results) => {\n        const lastResult = results[results.length - 1];\n        if (lastResult.status === 'fulfilled') {\n          return undefined;\n        }\n        throw lastResult.reason;\n      }),\n    };\n  }\n\n  /**\n   * Sets the local value of the signal without sending any events to the server\n   * @param value - The new value.\n   * @internal\n   */\n  protected [$setValueQuietly](value: T): void {\n    this.#paused = true;\n    super.value = value;\n    this.#paused = false;\n  }\n\n  /**\n   * A method to update the server with the new value.\n   *\n   * @param event - The event to update the server with.\n   * @returns The server response promise.\n   */\n  protected async [$update](event: StateEvent): Promise<void> {\n    return this.server\n      .update(event)\n      .catch((error: unknown) => {\n        this.#error.value = error instanceof Error ? error : new Error(String(error));\n      })\n      .finally(() => {\n        this.#pending.value = false;\n      });\n  }\n\n  /**\n   * Resolves the operation promise associated with the given event id.\n   *\n   * @param eventId - The event id.\n   * @param reason - The reason to reject the promise (if any).\n   */\n  protected [$resolveOperation](eventId: string, reason?: string): void {\n    const operationPromise = this.#operationPromises.get(eventId);\n    if (operationPromise) {\n      this.#operationPromises.delete(eventId);\n      if (reason) {\n        operationPromise.reject(reason);\n      } else {\n        operationPromise.resolve();\n      }\n    }\n  }\n\n  /**\n   * A method with to process the server response. The implementation is\n   * specific for each signal type.\n   *\n   * @param event - The server response event.\n   */\n  protected abstract [$processServerResponse](event: StateEvent): void;\n\n  #connect() {\n    this.server\n      .connect()\n      .onSubscriptionLost(() => 'resubscribe' as ActionOnLostSubscription)\n      .onNext((event: StateEvent) => {\n        this.#paused = true;\n        this[$processServerResponse](event);\n        this.#paused = false;\n      });\n  }\n\n  #disconnect() {\n    if (this.server.subscription === undefined) {\n      return;\n    }\n    this.server.disconnect();\n  }\n}\n"]}