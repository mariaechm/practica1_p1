{"version":3,"file":"ValueSignal.js","sourceRoot":"","sources":["src/ValueSignal.ts"],"names":[],"mappings":"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","sourcesContent":["import { nanoid } from 'nanoid';\nimport {\n  createReplaceStateEvent,\n  createSetStateEvent,\n  isReplaceStateEvent,\n  isSetStateEvent,\n  isSnapshotStateEvent,\n  type StateEvent,\n} from './events.js';\nimport {\n  $createOperation,\n  $processServerResponse,\n  $resolveOperation,\n  $setValueQuietly,\n  $update,\n  FullStackSignal,\n  type Operation,\n} from './FullStackSignal.js';\n\ntype PendingRequestsRecord<T> = Readonly<{\n  id: string;\n  callback(value: T): T;\n}> & { canceled: boolean };\n\n/**\n * An operation subscription that can be canceled.\n */\nexport interface OperationSubscription extends Operation {\n  cancel(): void;\n}\n\n/**\n * A full-stack signal that holds an arbitrary value.\n */\nexport class ValueSignal<T> extends FullStackSignal<T> {\n  readonly #pendingRequests = new Map<string, PendingRequestsRecord<T>>();\n\n  /**\n   * Sets the value.\n   * Note that the value change event that is propagated to the server as the\n   * result of this operation is not taking the last seen value into account and\n   * will overwrite the shared value on the server unconditionally (AKA: \"Last\n   * Write Wins\"). If you need to perform a conditional update, use the\n   * `replace` method instead.\n   *\n   * @param value - The new value.\n   * @returns An operation object that allows to perform additional actions.\n   */\n  set(value: T): Operation {\n    const { parentClientSignalId } = this.server.config;\n    const signalId = parentClientSignalId !== undefined ? this.id : undefined;\n    const event = createSetStateEvent(value, signalId, parentClientSignalId);\n    const promise = this[$update](event);\n    this[$setValueQuietly](value);\n    return this[$createOperation]({ id: event.id, promise });\n  }\n\n  /**\n   * Replaces the value with a new one only if the current value is equal to the\n   * expected value.\n   *\n   * @param expected - The expected value.\n   * @param newValue - The new value.\n   * @returns An operation object that allows to perform additional actions.\n   */\n  replace(expected: T, newValue: T): Operation {\n    const { parentClientSignalId } = this.server.config;\n    const signalId = parentClientSignalId !== undefined ? this.id : undefined;\n    const event = createReplaceStateEvent(expected, newValue, signalId, parentClientSignalId);\n    const promise = this[$update](event);\n    return this[$createOperation]({ id: event.id, promise });\n  }\n\n  /**\n   * Tries to update the value by applying the callback function to the current\n   * value. In case of a concurrent change, the callback is run again with an\n   * updated input value. This is repeated until the result can be applied\n   * without concurrent changes, or the operation is canceled.\n   *\n   * Note that there is no guarantee that cancel() will be effective always,\n   * since a succeeding operation might already be on its way to the server.\n   *\n   * @param callback - The function that is applied on the current value to\n   *                   produce the new value.\n   * @returns An operation object that allows to perform additional actions,\n   *                   including cancellation.\n   */\n  update(callback: (value: T) => T): OperationSubscription {\n    const newValue = callback(this.value);\n    const event = createReplaceStateEvent(this.value, newValue);\n    const promise = this[$update](event);\n    const pendingRequest = { id: nanoid(), callback, canceled: false };\n    this.#pendingRequests.set(event.id, pendingRequest);\n    return {\n      ...this[$createOperation]({ id: pendingRequest.id, promise }),\n      cancel: () => {\n        pendingRequest.canceled = true;\n      },\n    };\n  }\n\n  protected override [$processServerResponse](event: StateEvent): void {\n    const record = this.#pendingRequests.get(event.id);\n    if (record) {\n      this.#pendingRequests.delete(event.id);\n\n      if (!(event.accepted || record.canceled)) {\n        this.update(record.callback);\n      }\n    }\n\n    let reason: string | undefined;\n    if (event.accepted || isSnapshotStateEvent<T>(event)) {\n      this.#applyAcceptedEvent(event);\n    } else {\n      reason = `Server rejected the operation with id '${event.id}'. See the server log for more details.`;\n    }\n    // `then` callbacks can be associated to the record or the event\n    // it depends on the operation that was performed\n    [record?.id, event.id].filter(Boolean).forEach((id) => this[$resolveOperation](id!, reason));\n  }\n\n  #applyAcceptedEvent(event: StateEvent): void {\n    if (isSetStateEvent<T>(event) || isSnapshotStateEvent<T>(event)) {\n      this.value = event.value;\n    } else if (isReplaceStateEvent<T>(event)) {\n      if (JSON.stringify(this.value) === JSON.stringify(event.expected)) {\n        this.value = event.value;\n      }\n    }\n  }\n}\n"]}