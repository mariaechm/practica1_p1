{"version":3,"file":"model-info.js","sourceRoot":"","sources":["src/model-info.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,YAAY,EACZ,WAAW,EACX,WAAW,EACX,KAAK,EACL,mBAAmB,EAInB,SAAS,EACT,WAAW,GACZ,MAAM,wBAAwB,CAAC;AAchC,MAAM,WAAW,GAAiC;IAChD,IAAI,EAAE,SAAS;IACf,gBAAgB,EAAE,SAAS;IAC3B,KAAK,EAAE,SAAS;IAChB,iBAAiB,EAAE,SAAS;IAC5B,GAAG,EAAE,SAAS;IACd,mBAAmB,EAAE,SAAS;IAC9B,IAAI,EAAE,SAAS;IACf,gBAAgB,EAAE,SAAS;IAC3B,KAAK,EAAE,SAAS;IAChB,iBAAiB,EAAE,SAAS;IAC5B,MAAM,EAAE,SAAS;IACjB,kBAAkB,EAAE,SAAS;IAC7B,qBAAqB,EAAE,MAAM;IAC7B,qBAAqB,EAAE,MAAM;IAC7B,sBAAsB,EAAE,MAAM;IAC9B,yBAAyB,EAAE,UAAU;IACrC,0BAA0B,EAAE,UAAU;IACtC,yBAAyB,EAAE,UAAU;IACrC,gBAAgB,EAAE,UAAU;IAC5B,eAAe,EAAE,UAAU;CAC5B,CAAC;AAEF,SAAS,qBAAqB,CAAC,KAAoB;IAEjD,MAAM,EAAE,QAAQ,EAAE,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC;IAClC,MAAM,YAAY,GAAG,QAAQ,CAAC,CAAC,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;IAClE,IAAI,YAAY,EAAE,CAAC;QACjB,OAAO,YAAY,CAAC;IACtB,CAAC;IAGD,IAAI,KAAK,YAAY,WAAW,EAAE,CAAC;QACjC,OAAO,QAAQ,CAAC;IAClB,CAAC;SAAM,IAAI,KAAK,YAAY,WAAW,EAAE,CAAC;QACxC,OAAO,SAAS,CAAC;IACnB,CAAC;SAAM,IAAI,KAAK,YAAY,YAAY,EAAE,CAAC;QACzC,OAAO,SAAS,CAAC;IACnB,CAAC;SAAM,IAAI,KAAK,YAAY,SAAS,EAAE,CAAC;QACtC,OAAO,MAAM,CAAC;IAChB,CAAC;SAAM,IAAI,KAAK,YAAY,WAAW,EAAE,CAAC;QACxC,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED,OAAO,SAAS,CAAC;AACnB,CAAC;AAUD,MAAM,UAAU,aAAa,CAAC,IAAmB,EAAE,cAAsB;IACvE,OAAO,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC,UAAU,EAAE,EAAE,CAAC,UAAU,CAAC,IAAI,KAAK,cAAc,CAAC,IAAI,KAAK,CAAC;AAC7F,CAAC;AAGD,MAAM,UAAU,eAAe,CAAC,IAAY;IAC1C,OAAO,IAAI;SACR,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;SACpC,OAAO,CAAC,WAAW,EAAE,KAAK,CAAC;SAC3B,WAAW,EAAE;SACb,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC;SACnB,OAAO,CAAC,KAAK,EAAE,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,CAAC;AACpD,CAAC;AAED,MAAM,gBAAgB,GAAG,CAAC,KAA8C,EAAY,EAAE;IACpF,MAAM,aAAa,GAAa,EAAE,CAAC;IAEnC,KAAK,IAAI,KAAK,GAAG,KAAK,EAAE,KAAK,KAAK,WAAW,EAAE,KAAK,GAAG,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,EAAE,CAAC;QAEpF,aAAa,CAAC,OAAO,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,yBAAyB,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC;IACtH,CAAC;IAED,OAAO,aAAa,CAAC;AACvB,CAAC,CAAC;AAEF,MAAM,OAAO,SAAS;IACH,aAAa,CAAgB;IAErC,UAAU,CAAgB;IAEnC,YAAY,KAA8C,EAAE,cAAuB;QACjF,IAAI,CAAC,aAAa,GAAG,mBAAmB,CAAC,KAAK,CAAC,CAAC;QAGhD,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC,iBAAiB,CAAC,IAAI,EAAE,cAAc,CAAC,CAAC;IACtE,CAAC;IAEO,MAAM,CAAC,iBAAiB,CAAC,SAAoB,EAAE,cAAuB;QAE5E,IAAI,cAAc,EAAE,CAAC;YACnB,OAAO,SAAS,CAAC,WAAW,CAAC,cAAc,CAAC,CAAC;QAC/C,CAAC;QAGD,MAAM,cAAc,GAAG,SAAS,CAAC,iBAAiB,EAAE,CAAC;QAErD,IAAI,UAAU,GAAG,cAAc,CAAC,IAAI,CAAC,CAAC,YAAY,EAAE,EAAE,CAAC,aAAa,CAAC,YAAY,CAAC,IAAI,EAAE,wBAAwB,CAAC,CAAC,CAAC;QAEnH,UAAU,KAAK,cAAc,CAAC,IAAI,CAAC,CAAC,YAAY,EAAE,EAAE,CAAC,YAAY,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC;QAEjF,OAAO,UAAU,CAAC;IACpB,CAAC;IAEO,MAAM,CAAC,oBAAoB,CAAC,aAA4B,EAAE,IAAY;QAC5E,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAC9B,IAAI,YAAY,GAA8B,aAAa,CAAC;QAC5D,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;YACzB,IAAI,CAAC,YAAY,IAAI,CAAC,CAAC,YAAY,YAAY,WAAW,CAAC,EAAE,CAAC;gBAC5D,OAAO,SAAS,CAAC;YACnB,CAAC;YAED,YAAY,GAAI,YAAoB,CAAC,IAAI,CAAC,CAAC;QAC7C,CAAC;QACD,OAAO,YAAY,CAAC;IACtB,CAAC;IAED,iBAAiB,CAAC,IAAa;QAC7B,MAAM,KAAK,GAAG,IAAI,CAAC,CAAC,CAAC,SAAS,CAAC,oBAAoB,CAAC,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC;QACnG,IAAI,CAAC,KAAK,EAAE,CAAC;YACX,OAAO,EAAE,CAAC;QACZ,CAAC;QACD,OAAO,gBAAgB,CAAC,KAAK,CAAC,WAAkB,CAAC;aAC9C,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE;YACZ,MAAM,aAAa,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,IAAI,IAAI,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC;YACtD,OAAO,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC,CAAC;QACzC,CAAC,CAAC;aACD,MAAM,CAAC,OAAO,CAAmB,CAAC;IACvC,CAAC;IAED,WAAW,CAAC,IAAY;QACtB,MAAM,aAAa,GAAG,SAAS,CAAC,oBAAoB,CAAC,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,CAAC;QAC/E,IAAI,CAAC,aAAa,EAAE,CAAC,KAAK,CAAC,EAAE,CAAC;YAC5B,OAAO,SAAS,CAAC;QACnB,CAAC;QAED,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAClC,MAAM,IAAI,GAAG,SAAS,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAE7C,MAAM,IAAI,GAAG,aAAa,CAAC,KAAK,CAAC,CAAC;QAClC,MAAM,iBAAiB,GAAG,eAAe,CAAC,IAAI,CAAC,CAAC;QAChD,MAAM,IAAI,GAAG,qBAAqB,CAAC,aAAa,CAAC,CAAC;QAElD,OAAO;YACL,IAAI,EAAE,IAAI;YACV,iBAAiB;YACjB,IAAI;YACJ,IAAI;YACJ,KAAK,EAAE,aAAa;SACrB,CAAC;IACJ,CAAC;IAED,aAAa,CAAC,KAAe;QAC3B,OAAO,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,OAAO,CAAmB,CAAC;IACvF,CAAC;CACF;AAED,MAAM,UAAU,oBAAoB,CAAC,SAAoB;IAEvD,MAAM,UAAU,GAAG,SAAS,CAAC,iBAAiB,EAAE,CAAC;IACjD,OAAO,CACL,UAAU;SAEP,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QAChB,IAAI,aAAa,CAAC,IAAI,CAAC,IAAI,EAAE,8BAA8B,CAAC,EAAE,CAAC;YAC7D,OAAO,SAAS,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAChD,CAAC;QACD,OAAO,IAAI,CAAC;IACd,CAAC,CAAC;SAGD,MAAM,CACL,CAAC,IAAI,EAAE,EAAE,CACP,CAAC,CAAC,IAAI,CAAC,IAAI;QACX,CAAC,CACC,aAAa,CAAC,IAAI,CAAC,IAAI,EAAE,wBAAwB,CAAC;YAClD,aAAa,CAAC,IAAI,CAAC,IAAI,EAAE,6BAA6B,CAAC,CACxD,CACJ,CACJ,CAAC;AACJ,CAAC","sourcesContent":["import {\n  BooleanModel,\n  NumberModel,\n  StringModel,\n  _meta,\n  createDetachedModel,\n  type AbstractModel,\n  type DetachedModelConstructor,\n  type ModelMetadata,\n  EnumModel,\n  ObjectModel,\n} from '@vaadin/hilla-lit-form';\n\nexport type PropertyType =\n  | 'boolean'\n  | 'date'\n  | 'datetime'\n  | 'decimal'\n  | 'enum'\n  | 'integer'\n  | 'object'\n  | 'string'\n  | 'time'\n  | undefined;\n\nconst javaTypeMap: Record<string, PropertyType> = {\n  byte: 'integer',\n  'java.lang.Byte': 'integer',\n  short: 'integer',\n  'java.lang.Short': 'integer',\n  int: 'integer',\n  'java.lang.Integer': 'integer',\n  long: 'integer',\n  'java.lang.Long': 'integer',\n  float: 'decimal',\n  'java.lang.Float': 'decimal',\n  double: 'decimal',\n  'java.lang.Double': 'decimal',\n  'java.time.LocalDate': 'date',\n  'java.time.LocalTime': 'time',\n  'java.time.OffsetTime': 'time',\n  'java.time.LocalDateTime': 'datetime',\n  'java.time.OffsetDateTime': 'datetime',\n  'java.time.ZonedDateTime': 'datetime',\n  'java.util.Date': 'datetime',\n  'java.sql.Date': 'datetime',\n};\n\nfunction determinePropertyType(model: AbstractModel): PropertyType {\n  // Try detecting by Java type\n  const { javaType } = model[_meta];\n  const propertyType = javaType ? javaTypeMap[javaType] : undefined;\n  if (propertyType) {\n    return propertyType;\n  }\n\n  // Otherwise detect by model instance\n  if (model instanceof StringModel) {\n    return 'string';\n  } else if (model instanceof NumberModel) {\n    return 'decimal';\n  } else if (model instanceof BooleanModel) {\n    return 'boolean';\n  } else if (model instanceof EnumModel) {\n    return 'enum';\n  } else if (model instanceof ObjectModel) {\n    return 'object';\n  }\n\n  return undefined;\n}\n\nexport interface PropertyInfo {\n  name: string;\n  humanReadableName: string;\n  type: PropertyType;\n  meta: ModelMetadata;\n  model: AbstractModel;\n}\n\nexport function hasAnnotation(meta: ModelMetadata, annotationName: string): boolean {\n  return meta.annotations?.some((annotation) => annotation.name === annotationName) ?? false;\n}\n\n// This is from vaadin-grid-column.js, should be used from there maybe. At least we must be 100% sure to match grid and fields\nexport function _generateHeader(path: string): string {\n  return path\n    .substring(path.lastIndexOf('.') + 1)\n    .replace(/([A-Z])/gu, '-$1')\n    .toLowerCase()\n    .replace(/-/gu, ' ')\n    .replace(/^./u, (match) => match.toUpperCase());\n}\n\nconst getPropertyNames = (model: DetachedModelConstructor<AbstractModel>): string[] => {\n  const propertyNames: string[] = [];\n\n  for (let proto = model; proto !== ObjectModel; proto = Object.getPrototypeOf(proto)) {\n    // parent properties are added at the beginning\n    propertyNames.unshift(...Object.keys(Object.getOwnPropertyDescriptors(proto.prototype)).filter((p) => p !== 'new'));\n  }\n\n  return propertyNames;\n};\n\nexport class ModelInfo {\n  private readonly modelInstance: AbstractModel;\n\n  readonly idProperty?: PropertyInfo;\n\n  constructor(model: DetachedModelConstructor<AbstractModel>, idPropertyName?: string) {\n    this.modelInstance = createDetachedModel(model);\n\n    // Try to find id property\n    this.idProperty = ModelInfo.resolveIdProperty(this, idPropertyName);\n  }\n\n  private static resolveIdProperty(modelInfo: ModelInfo, idPropertyName?: string): PropertyInfo | undefined {\n    // Return explicit property if defined\n    if (idPropertyName) {\n      return modelInfo.getProperty(idPropertyName);\n    }\n\n    // Otherwise check defaults\n    const rootProperties = modelInfo.getRootProperties();\n    // Check for @Id annotation\n    let idProperty = rootProperties.find((propertyInfo) => hasAnnotation(propertyInfo.meta, 'jakarta.persistence.Id'));\n    // Check for id name as fallback\n    idProperty ??= rootProperties.find((propertyInfo) => propertyInfo.name === 'id');\n\n    return idProperty;\n  }\n\n  private static resolvePropertyModel(modelInstance: AbstractModel, path: string): AbstractModel | undefined {\n    const parts = path.split('.');\n    let currentModel: AbstractModel | undefined = modelInstance;\n    for (const part of parts) {\n      if (!currentModel || !(currentModel instanceof ObjectModel)) {\n        return undefined;\n      }\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      currentModel = (currentModel as any)[part];\n    }\n    return currentModel;\n  }\n\n  getRootProperties(path?: string): PropertyInfo[] {\n    const model = path ? ModelInfo.resolvePropertyModel(this.modelInstance, path) : this.modelInstance;\n    if (!model) {\n      return [];\n    }\n    return getPropertyNames(model.constructor as any)\n      .map((name) => {\n        const effectivePath = path ? `${path}.${name}` : name;\n        return this.getProperty(effectivePath);\n      })\n      .filter(Boolean) as PropertyInfo[];\n  }\n\n  getProperty(path: string): PropertyInfo | undefined {\n    const propertyModel = ModelInfo.resolvePropertyModel(this.modelInstance, path);\n    if (!propertyModel?.[_meta]) {\n      return undefined;\n    }\n\n    const pathParts = path.split('.');\n    const name = pathParts[pathParts.length - 1];\n\n    const meta = propertyModel[_meta];\n    const humanReadableName = _generateHeader(name);\n    const type = determinePropertyType(propertyModel);\n\n    return {\n      name: path,\n      humanReadableName,\n      type,\n      meta,\n      model: propertyModel,\n    };\n  }\n\n  getProperties(paths: string[]): PropertyInfo[] {\n    return paths.map((path) => this.getProperty(path)).filter(Boolean) as PropertyInfo[];\n  }\n}\n\nexport function getDefaultProperties(modelInfo: ModelInfo): PropertyInfo[] {\n  // Start from root properties\n  const properties = modelInfo.getRootProperties();\n  return (\n    properties\n      // Auto-expand nested properties of one-to-one relations\n      .flatMap((prop) => {\n        if (hasAnnotation(prop.meta, 'jakarta.persistence.OneToOne')) {\n          return modelInfo.getRootProperties(prop.name);\n        }\n        return prop;\n      })\n      // Exclude properties that have an unknown type, or are annotated with id\n      // and version\n      .filter(\n        (prop) =>\n          !!prop.type &&\n          !(\n            hasAnnotation(prop.meta, 'jakarta.persistence.Id') ||\n            hasAnnotation(prop.meta, 'jakarta.persistence.Version')\n          ),\n      )\n  );\n}\n"]}