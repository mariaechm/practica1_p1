{"version":3,"file":"autogrid.js","sourceRoot":"","sources":["src/autogrid.tsx"],"names":[],"mappings":"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","sourcesContent":["import type { AbstractModel, DetachedModelConstructor } from '@vaadin/hilla-lit-form';\nimport { Grid, type GridElement, type GridProps } from '@vaadin/react-components/Grid.js';\nimport { GridColumn } from '@vaadin/react-components/GridColumn.js';\nimport { GridColumnGroup } from '@vaadin/react-components/GridColumnGroup.js';\nimport {\n  cloneElement,\n  type ComponentType,\n  type ForwardedRef,\n  forwardRef,\n  type JSX,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport { ColumnContext, CustomColumnContext, type SortState } from './autogrid-column-context.js';\nimport { type ColumnOptions, getColumnOptions } from './autogrid-columns.js';\nimport { AutoGridFooterItemCountRenderer, AutoGridRowNumberRenderer, FooterContext } from './autogrid-renderers.js';\nimport css from './autogrid.obj.js';\nimport type { ListService } from './crud.js';\nimport { createDataProvider, type DataProvider, isCountService, type ItemCounts } from './data-provider.js';\nimport { type HeaderFilterRendererProps, NoHeaderFilter, HeaderFilterWrapper } from './header-filter';\nimport { HeaderSorter } from './header-sorter';\nimport { getDefaultProperties, ModelInfo, type PropertyInfo } from './model-info.js';\nimport type AndFilter from './types/com/vaadin/hilla/crud/filter/AndFilter.js';\nimport type FilterUnion from './types/com/vaadin/hilla/crud/filter/FilterUnion.js';\nimport { isFilterEmpty, registerStylesheet } from './util';\n\nregisterStylesheet(css);\n\nexport interface AutoGridRef<TItem = any> {\n  /**\n   * The underlying vaadin-grid DOM element.\n   */\n  grid: GridElement<TItem> | null;\n\n  /**\n   * Refreshes the grid by reloading the data from the backend.\n   */\n  refresh(): void;\n}\n\ninterface AutoGridOwnProps<TItem> {\n  /**\n   * The service to use for fetching the data. This must be a TypeScript service\n   * that has been generated by Hilla from a backend Java service that\n   * implements the `com.vaadin.hilla.crud.ListService` interface.\n   */\n  service: ListService<TItem>;\n  /**\n   * The entity model to use for the grid, which determines which columns to\n   * show and how to render them. This must be a Typescript model class that has\n   * been generated by Hilla from a backend Java class. The model must match\n   * with the type of the items returned by the service. For example, a\n   * `PersonModel` can be used with a service that returns `Person` instances.\n   *\n   * By default, the grid shows columns for all properties of the model which\n   * have a type that is supported. Use the `visibleColumns` option to customize\n   * which columns to show and in which order.\n   */\n  model: DetachedModelConstructor<AbstractModel<TItem>>;\n  /**\n   * The property to use to detect an item's ID. The item ID is used to keep\n   * the selection state when reloading the grid.\n   *\n   * By default, the component uses the property annotated with\n   * `jakarta.persistence.Id`, or a property named `id`, in that order.\n   * This option can be used to override the default behavior, or define the ID\n   * property in case a class doesn't have a property matching the defaults.\n   */\n  itemIdProperty?: string;\n  /**\n   * Allows to provide a filter that is applied when fetching data from the\n   * service. This can be used for implementing an external filter UI outside\n   * the grid. A custom filter is not compatible with header filters.\n   *\n   * **NOTE:** This is considered an experimental feature and the API may change\n   * in the future.\n   */\n  experimentalFilter?: FilterUnion;\n  /**\n   * Allows to customize which columns to show and in which order. This must be\n   * an array of property names that are defined in the model. Nested properties\n   * can be specified using dot notation, e.g. `address.street`.\n   */\n  visibleColumns?: string[];\n  /**\n   * Allows to customize which columns to hide. This must be an array of property\n   * names that are defined in the model. Nested properties can be specified using\n   * dot notation, e.g. `address.street`.\n   */\n  hiddenColumns?: string[];\n  /**\n   * Disables header filters, which are otherwise enabled by default.\n   */\n  noHeaderFilters?: boolean;\n  /**\n   * Allows to add custom columns to the grid. This must be an array of\n   * `GridColumn` component instances. Custom columns are added after the\n   * auto-generated columns.\n   */\n  customColumns?: JSX.Element[];\n  /**\n   * Allows to customize the props for individual columns. This is an object\n   * where the keys must be property names that are defined in the model, and\n   * the values are props that are accepted by the `GridColumn` component.\n   * Nested properties can be specified using dot notation, e.g.\n   * `address.street`.\n   */\n  columnOptions?: Record<string, ColumnOptions>;\n  /**\n   * When enabled, inserts a column with row numbers at the beginning of the\n   * grid.\n   */\n  rowNumbers?: boolean;\n  /**\n   * When enabled, shows the total count of items in the grid footer.\n   * This requires the provided service to implement the CountService interface,\n   *  otherwise an error will be logged to the console, without any count being\n   *  rendered.\n   */\n  totalCount?: boolean;\n  /**\n   * When enabled, shows the filtered item count in the grid footer.\n   * if totalCount is also enabled, it will show both totalCount and filteredCount.\n   * This requires the provided service to implement the CountService interface,\n   *  otherwise an error will be logged to the console, without any count being\n   *  rendered.\n   */\n  filteredCount?: boolean;\n  /**\n   * Allows to customize the grid footer with a custom renderer component for\n   *  the total count and filtered item count.\n   * This requires the provided service to implement the CountService interface,\n   * See {@link AutoGrid#totalCount} and {@link AutoGrid#filteredCount}.\n   */\n  footerCountRenderer?: ComponentType<ItemCounts>;\n}\n\nexport type AutoGridProps<TItem> = GridProps<TItem> & Readonly<AutoGridOwnProps<TItem>>;\n\ninterface ColumnConfigurationOptions {\n  visibleColumns?: string[];\n  hiddenColumns?: string[];\n  noHeaderFilters?: boolean;\n  customColumns?: JSX.Element[];\n  columnOptions?: Record<string, ColumnOptions>;\n  rowNumbers?: boolean;\n  totalCount?: boolean;\n  filteredCount?: boolean;\n  footerCountRenderer?: ComponentType<ItemCounts>;\n  itemCounts?: ItemCounts;\n}\n\nfunction wrapCustomColumn(\n  column: JSX.Element,\n  setColumnFilter: (filter: FilterUnion, filterKey: string) => void,\n  options: ColumnConfigurationOptions,\n) {\n  const key = column.key ?? 'no-key';\n  const { header, headerRenderer } = column.props;\n  const customOptions = options.columnOptions?.[key];\n  const { header: customHeader, headerRenderer: customHeaderRenderer, headerFilterRenderer } = customOptions ?? {};\n  const columnWithoutHeader = cloneElement(column, {\n    header: null,\n    headerRenderer: HeaderFilterWrapper,\n  });\n  return (\n    <CustomColumnContext.Provider\n      key={key}\n      value={{\n        setColumnFilter,\n        headerFilterRenderer: headerFilterRenderer ?? NoHeaderFilter,\n        filterKey: key,\n      }}\n    >\n      <GridColumnGroup\n        key={key}\n        header={customHeader ?? header}\n        headerRenderer={customHeaderRenderer ?? headerRenderer}\n      >\n        {columnWithoutHeader}\n      </GridColumnGroup>\n    </CustomColumnContext.Provider>\n  );\n}\n\nfunction addCustomColumns(\n  columns: JSX.Element[],\n  options: ColumnConfigurationOptions,\n  setColumnFilter: (filter: FilterUnion, filterKey: string) => void,\n): JSX.Element[] {\n  if (!options.customColumns) {\n    return columns;\n  }\n\n  // When using header filters, wrap custom columns into column groups and\n  // move header text or renderer to group\n  const customColumns = options.noHeaderFilters\n    ? options.customColumns\n    : options.customColumns.map((column) => wrapCustomColumn(column, setColumnFilter, options));\n\n  // When using a custom column order, insert custom columns into auto-generated\n  // ones using their `key`\n  if (options.visibleColumns) {\n    const columnMap = [...columns, ...customColumns].reduce((map, column) => {\n      const { key } = column;\n      if (key) {\n        map.set(key, column);\n      }\n      return map;\n    }, new Map<string, JSX.Element>());\n\n    return options.visibleColumns.map((path) => columnMap.get(path)).filter(Boolean) as JSX.Element[];\n  }\n\n  // Otherwise just append custom columns at the end\n  return [...columns, ...customColumns];\n}\n\nfunction useColumns(\n  properties: PropertyInfo[],\n  setColumnFilter: (filter: FilterUnion, filterKey: string) => void,\n  options: ColumnConfigurationOptions,\n) {\n  const sortableProperties = properties.filter(\n    (propertyInfo) => options.columnOptions?.[propertyInfo.name]?.sortable !== false,\n  );\n  const [sortState, setSortState] = useState<SortState>(\n    sortableProperties.length > 0 ? { [sortableProperties[0].name]: { direction: 'asc' } } : {},\n  );\n  let columns = properties.map((propertyInfo) => {\n    let column;\n    const customColumnOptions = options.columnOptions?.[propertyInfo.name];\n\n    const { headerFilterRenderer, ...columnProps } = getColumnOptions(propertyInfo, customColumnOptions);\n\n    if (!options.noHeaderFilters) {\n      column = (\n        <GridColumnGroup headerRenderer={HeaderSorter}>\n          <GridColumn path={propertyInfo.name} headerRenderer={HeaderFilterWrapper} {...columnProps}></GridColumn>\n        </GridColumnGroup>\n      );\n    } else {\n      column = <GridColumn path={propertyInfo.name} headerRenderer={HeaderSorter} {...columnProps}></GridColumn>;\n    }\n    return (\n      <ColumnContext.Provider\n        key={propertyInfo.name}\n        value={{\n          propertyInfo,\n          setColumnFilter,\n          sortState,\n          setSortState,\n          customColumnOptions,\n          headerFilterRenderer: headerFilterRenderer ?? NoHeaderFilter,\n          filterKey: propertyInfo.name,\n        }}\n      >\n        {column}\n      </ColumnContext.Provider>\n    );\n  });\n\n  columns = addCustomColumns(columns, options, setColumnFilter);\n\n  // When using `hiddenColumns` option, remove columns to hide using their `key`\n  if (options.hiddenColumns) {\n    columns = columns.filter(({ key }) => !(key && options.hiddenColumns?.includes(key)));\n  }\n\n  if (options.rowNumbers) {\n    columns = [\n      <GridColumn key=\"rownumbers\" width=\"4em\" flexGrow={0} renderer={AutoGridRowNumberRenderer}></GridColumn>,\n      ...columns,\n    ];\n  }\n  const { totalCount, filteredCount, itemCounts, footerCountRenderer } = options;\n  if (totalCount ?? filteredCount) {\n    const col = (\n      <FooterContext.Provider\n        key=\"grid-footer\"\n        value={{\n          totalCount,\n          filteredCount,\n          footerCountRenderer,\n          itemCounts,\n        }}\n      >\n        <GridColumnGroup footerRenderer={AutoGridFooterItemCountRenderer}>{columns}</GridColumnGroup>\n      </FooterContext.Provider>\n    );\n    columns = [col];\n  }\n\n  return columns;\n}\n\nfunction AutoGridInner<TItem>(\n  {\n    service,\n    model,\n    itemIdProperty,\n    experimentalFilter,\n    visibleColumns,\n    hiddenColumns,\n    noHeaderFilters,\n    customColumns,\n    columnOptions,\n    rowNumbers,\n    totalCount,\n    filteredCount,\n    footerCountRenderer,\n    ...gridProps\n  }: AutoGridProps<TItem>,\n  ref: ForwardedRef<AutoGridRef<TItem>>,\n): JSX.Element {\n  const [internalFilter, setInternalFilter] = useState<AndFilter>({ '@type': 'and', children: [] });\n  const [itemCounts, setItemCounts] = useState<ItemCounts | undefined>();\n  const gridRef = useRef<GridElement<TItem>>(null);\n  const dataProviderRef = useRef<DataProvider<TItem>>(undefined);\n\n  useImperativeHandle(\n    ref,\n    () => ({\n      get grid() {\n        return gridRef.current;\n      },\n      refresh() {\n        dataProviderRef.current?.reset();\n        gridRef.current?.clearCache();\n      },\n    }),\n    [],\n  );\n\n  const setHeaderFilter = (filter: FilterUnion, filterKey: string) => {\n    let changed = false;\n    filter.key = filterKey;\n    const indexOfFilter = filterKey\n      ? internalFilter.children.findIndex((f) => (f as FilterUnion).key === filterKey)\n      : -1;\n    const isEmptyFilter = isFilterEmpty(filter);\n\n    if (indexOfFilter >= 0 && isEmptyFilter) {\n      internalFilter.children.splice(indexOfFilter, 1);\n      changed = true;\n    } else if (!isEmptyFilter) {\n      if (indexOfFilter >= 0) {\n        internalFilter.children[indexOfFilter] = filter;\n        changed = true;\n      } else {\n        internalFilter.children.push(filter);\n        changed = true;\n      }\n    }\n    if (changed) {\n      setInternalFilter({ ...internalFilter });\n    }\n  };\n\n  const modelInfo = useMemo(() => new ModelInfo(model, itemIdProperty), [model]);\n  const properties = visibleColumns ? modelInfo.getProperties(visibleColumns) : getDefaultProperties(modelInfo);\n  const children = useColumns(properties, setHeaderFilter, {\n    visibleColumns,\n    hiddenColumns,\n    noHeaderFilters,\n    customColumns,\n    columnOptions,\n    rowNumbers,\n    totalCount,\n    filteredCount,\n    footerCountRenderer,\n    itemCounts,\n  });\n\n  useEffect(() => {\n    // Remove all filtering if header filters are removed\n    if (noHeaderFilters) {\n      setInternalFilter({ '@type': 'and', children: [] });\n    }\n  }, [noHeaderFilters]);\n\n  useEffect(() => {\n    // Log an error if totalCount or filteredCount is enabled but the service doesn't implement CountService\n    if ((!isCountService(service) && totalCount) ?? filteredCount) {\n      console.error(\n        '\"totalCount\" and \"filteredCount\" props require the provided service to implement the CountService interface.',\n      );\n    }\n    // Sets the data provider, should be done only once\n    const grid = gridRef.current!;\n    // Wait for the sorting headers to be rendered so that the sorting state is correct for the first data provider call\n    const timeoutId = setTimeout(() => {\n      let firstUpdate = true;\n      const dataProvider = createDataProvider(service, {\n        initialFilter: experimentalFilter ?? internalFilter,\n        loadTotalCount: totalCount,\n        afterLoad(newItemCounts: ItemCounts) {\n          setItemCounts(newItemCounts);\n\n          if (firstUpdate) {\n            // Workaround for https://github.com/vaadin/react-components/issues/129\n            firstUpdate = false;\n            setTimeout(() => grid.recalculateColumnWidths(), 0);\n          }\n        },\n      });\n      dataProviderRef.current = dataProvider;\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      gridRef.current!.dataProvider = dataProvider.load.bind(dataProvider);\n    }, 1);\n\n    return () => clearTimeout(timeoutId);\n  }, [model, service]);\n\n  useEffect(() => {\n    // Update the filtering, whenever the filter changes\n    const dataProvider = dataProviderRef.current;\n    const grid = gridRef.current;\n    if (grid && dataProvider) {\n      dataProvider.setFilter(experimentalFilter ?? internalFilter);\n      grid.clearCache();\n    }\n  }, [experimentalFilter, internalFilter]);\n\n  return (\n    <Grid itemIdPath={modelInfo.idProperty?.name} {...gridProps} ref={gridRef}>\n      {children}\n    </Grid>\n  );\n}\n\ntype AutoGrid = <TItem>(\n  props: AutoGridProps<TItem> & { ref?: ForwardedRef<AutoGridRef<TItem>> },\n) => ReturnType<typeof AutoGridInner>;\n\n/**\n * Auto Grid is a component for displaying tabular data based on a Java backend\n * service. It automatically generates columns based on the properties of a\n * Java class and provides features such as lazy-loading, sorting and filtering.\n *\n * Example usage:\n * ```tsx\n * import { AutoGrid } from '@vaadin/hilla-react-crud';\n * import PersonService from 'Frontend/generated/endpoints';\n * import PersonModel from 'Frontend/generated/com/example/application/Person';\n *\n * <AutoGrid service={PersonService} model={PersonModel} />\n * ```\n */\nexport const AutoGrid: AutoGrid = forwardRef(AutoGridInner) as AutoGrid;\n\nexport type { ColumnOptions, HeaderFilterRendererProps };\n"]}