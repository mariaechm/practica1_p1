{"mappings":"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","names":["#endpointInfos","#onCompleteCallbacks","#onErrorCallbacks","#onNextCallbacks","#onStateChangeCallbacks","#statusOfSubscriptions","connectPrefix: string","atmosphereOptions?: Partial<Atmosphere.Request>","#connectWebsocket","toBeRemoved: string[]","#setSubscriptionConnState","#send","#removeSubscription","endpointName: string","methodName: string","parameters?: unknown[]","id: string","#nextId","msg: ServerConnectMessage","hillaSubscription: Subscription<any>","closeMessage: ServerCloseMessage","context: ReactiveControllerHost","callback: () => void","callback: (message: string) => void","callback: (value: any) => void","callback: () => ActionOnLostSubscription | void","callback: (event: FluxSubscriptionStateChangeEvent) => void","prefix: string","atmosphereOptions: Partial<Atmosphere.Request>","#socket","#handleMessage","#resubscribeIfWasClosed","#sendPendingMessages","state: FluxSubscriptionState","message: unknown","message: ServerMessage","#pendingMessages"],"sources":["/opt/agent/work/1af72d8adc613024/hilla/packages/ts/frontend/src/FluxConnection.ts"],"sourcesContent":["import type { ReactiveControllerHost } from '@lit/reactive-element';\nimport atmosphere from 'atmosphere.js';\nimport type { Subscription } from './Connect.js';\nimport { getCsrfTokenHeadersForEndpointRequest } from './CsrfUtils.js';\nimport {\n  isClientMessage,\n  type ServerCloseMessage,\n  type ServerConnectMessage,\n  type ServerMessage,\n} from './FluxMessages.js';\n\nexport enum State {\n  ACTIVE = 'active',\n  INACTIVE = 'inactive',\n  RECONNECTING = 'reconnecting',\n}\n\ntype ActiveEvent = CustomEvent<{ active: boolean }>;\ninterface EventMap {\n  'state-changed': ActiveEvent;\n}\n\ntype ListenerType<T extends keyof EventMap> =\n  | ((this: FluxConnection, ev: EventMap[T]) => any)\n  | {\n      handleEvent(ev: EventMap[T]): void;\n    }\n  | null;\n\n/**\n * Possible options for dealing with lost subscriptions after a websocket is reopened.\n */\nexport enum ActionOnLostSubscription {\n  /**\n   * The subscription should be resubscribed using the same server method and parameters.\n   */\n  RESUBSCRIBE = 'resubscribe',\n  /**\n   * The subscription should be removed.\n   */\n  REMOVE = 'remove',\n}\n\n/**\n * Possible states of a flux subscription.\n */\nexport enum FluxSubscriptionState {\n  /**\n   * The subscription is not connected and is trying to connect.\n   */\n  CONNECTING = 'connecting',\n  /**\n   * The subscription is connected and receiving updates.\n   */\n  CONNECTED = 'connected',\n  /**\n   * The subscription is closed and is not trying to reconnect.\n   */\n  CLOSED = 'closed',\n}\n\n/**\n * Event wrapper for flux subscription connection state change callback\n */\nexport type FluxSubscriptionStateChangeEvent = CustomEvent<{ state: FluxSubscriptionState }>;\n\ntype EndpointInfo = {\n  endpointName: string;\n  methodName: string;\n  params: unknown[] | undefined;\n  reconnect?(): ActionOnLostSubscription | void;\n};\n\n/**\n * A representation of the underlying persistent network connection used for subscribing to Flux type endpoint methods.\n */\nexport class FluxConnection extends EventTarget {\n  state: State = State.INACTIVE;\n  wasClosed = false;\n  readonly #endpointInfos = new Map<string, EndpointInfo>();\n  #nextId = 0;\n  readonly #onCompleteCallbacks = new Map<string, () => void>();\n  readonly #onErrorCallbacks = new Map<string, (message: string) => void>();\n  readonly #onNextCallbacks = new Map<string, (value: any) => void>();\n  readonly #onStateChangeCallbacks = new Map<string, (event: FluxSubscriptionStateChangeEvent) => void>();\n  readonly #statusOfSubscriptions = new Map<string, FluxSubscriptionState>();\n  #pendingMessages: ServerMessage[] = [];\n  #socket?: Atmosphere.Request;\n\n  constructor(connectPrefix: string, atmosphereOptions?: Partial<Atmosphere.Request>) {\n    super();\n    this.#connectWebsocket(connectPrefix.replace(/connect$/u, ''), atmosphereOptions ?? {});\n  }\n\n  #resubscribeIfWasClosed() {\n    if (this.wasClosed) {\n      this.wasClosed = false;\n      const toBeRemoved: string[] = [];\n      this.#endpointInfos.forEach((endpointInfo, id) => {\n        if (endpointInfo.reconnect?.() === ActionOnLostSubscription.RESUBSCRIBE) {\n          this.#setSubscriptionConnState(id, FluxSubscriptionState.CONNECTING);\n          this.#send({\n            '@type': 'subscribe',\n            endpointName: endpointInfo.endpointName,\n            id,\n            methodName: endpointInfo.methodName,\n            params: endpointInfo.params,\n          });\n        } else {\n          toBeRemoved.push(id);\n        }\n      });\n      toBeRemoved.forEach((id) => this.#removeSubscription(id));\n    }\n  }\n\n  /**\n   * Subscribes to the flux returned by the given endpoint name + method name using the given parameters.\n   *\n   * @param endpointName - the endpoint to connect to\n   * @param methodName - the method in the endpoint to connect to\n   * @param parameters - the parameters to use\n   * @returns a subscription\n   */\n  subscribe(endpointName: string, methodName: string, parameters?: unknown[]): Subscription<any> {\n    const id: string = this.#nextId.toString();\n    this.#nextId += 1;\n    const params = parameters ?? [];\n\n    const msg: ServerConnectMessage = { '@type': 'subscribe', endpointName, id, methodName, params };\n    this.#send(msg);\n    this.#endpointInfos.set(id, { endpointName, methodName, params });\n    this.#setSubscriptionConnState(id, FluxSubscriptionState.CONNECTING);\n    const hillaSubscription: Subscription<any> = {\n      cancel: () => {\n        if (!this.#endpointInfos.has(id)) {\n          // Subscription already closed or canceled\n          return;\n        }\n\n        const closeMessage: ServerCloseMessage = { '@type': 'unsubscribe', id };\n        this.#send(closeMessage);\n        this.#removeSubscription(id);\n      },\n      context(context: ReactiveControllerHost): Subscription<any> {\n        context.addController({\n          hostDisconnected() {\n            hillaSubscription.cancel();\n          },\n        });\n        return hillaSubscription;\n      },\n      onComplete: (callback: () => void): Subscription<any> => {\n        this.#onCompleteCallbacks.set(id, callback);\n        return hillaSubscription;\n      },\n      onError: (callback: (message: string) => void): Subscription<any> => {\n        this.#onErrorCallbacks.set(id, callback);\n        return hillaSubscription;\n      },\n      onNext: (callback: (value: any) => void): Subscription<any> => {\n        this.#onNextCallbacks.set(id, callback);\n        return hillaSubscription;\n      },\n      onSubscriptionLost: (callback: () => ActionOnLostSubscription | void): Subscription<any> => {\n        if (this.#endpointInfos.has(id)) {\n          this.#endpointInfos.get(id)!.reconnect = callback;\n        } else {\n          console.warn(`\"onReconnect\" value not set for subscription \"${id}\" because it was already canceled`);\n        }\n        return hillaSubscription;\n      },\n      onConnectionStateChange: (callback: (event: FluxSubscriptionStateChangeEvent) => void): Subscription<any> => {\n        this.#onStateChangeCallbacks.set(id, callback);\n        callback(\n          new CustomEvent('subscription-state-change', { detail: { state: this.#statusOfSubscriptions.get(id)! } }),\n        );\n        return hillaSubscription;\n      },\n    };\n    return hillaSubscription;\n  }\n\n  #connectWebsocket(prefix: string, atmosphereOptions: Partial<Atmosphere.Request>) {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const extraHeaders = globalThis.document ? getCsrfTokenHeadersForEndpointRequest(globalThis.document) : {};\n    const pushUrl = 'HILLA/push';\n    const url = prefix.length === 0 ? pushUrl : (prefix.endsWith('/') ? prefix : `${prefix}/`) + pushUrl;\n    this.#socket = atmosphere.subscribe?.({\n      contentType: 'application/json; charset=UTF-8',\n      enableProtocol: true,\n      transport: 'websocket',\n      fallbackTransport: 'websocket',\n      headers: extraHeaders,\n      maxReconnectOnClose: 10000000,\n      reconnectInterval: 5000,\n      timeout: -1,\n      trackMessageLength: true,\n      url,\n      onClose: () => {\n        this.wasClosed = true;\n        if (this.state !== State.INACTIVE) {\n          this.state = State.INACTIVE;\n          this.dispatchEvent(new CustomEvent('state-changed', { detail: { active: false } }));\n        }\n      },\n      onError: (response) => {\n        // eslint-disable-next-line no-console\n        console.error('error in push communication', response);\n      },\n      onMessage: (response) => {\n        if (response.responseBody) {\n          this.#handleMessage(JSON.parse(response.responseBody));\n        }\n      },\n      onMessagePublished: (response) => {\n        if (response?.responseBody) {\n          this.#handleMessage(JSON.parse(response.responseBody));\n        }\n      },\n      onOpen: () => {\n        if (this.state !== State.ACTIVE) {\n          this.#resubscribeIfWasClosed();\n          this.state = State.ACTIVE;\n          this.dispatchEvent(new CustomEvent('state-changed', { detail: { active: true } }));\n          this.#sendPendingMessages();\n        }\n      },\n      onReopen: () => {\n        if (this.state !== State.ACTIVE) {\n          this.#resubscribeIfWasClosed();\n          this.state = State.ACTIVE;\n          this.dispatchEvent(new CustomEvent('state-changed', { detail: { active: true } }));\n          this.#sendPendingMessages();\n        }\n      },\n      onReconnect: () => {\n        if (this.state !== State.RECONNECTING) {\n          this.state = State.RECONNECTING;\n          this.#endpointInfos.forEach((_, id) => {\n            this.#setSubscriptionConnState(id, FluxSubscriptionState.CONNECTING);\n          });\n        }\n      },\n      onFailureToReconnect: () => {\n        if (this.state !== State.INACTIVE) {\n          this.state = State.INACTIVE;\n          this.dispatchEvent(new CustomEvent('state-changed', { detail: { active: false } }));\n          this.#endpointInfos.forEach((_, id) => this.#setSubscriptionConnState(id, FluxSubscriptionState.CLOSED));\n        }\n      },\n      ...atmosphereOptions,\n    } satisfies Atmosphere.Request);\n  }\n\n  #setSubscriptionConnState(id: string, state: FluxSubscriptionState) {\n    const currentState = this.#statusOfSubscriptions.get(id);\n    if (!currentState) {\n      this.#statusOfSubscriptions.set(id, state);\n      this.#onStateChangeCallbacks.get(id)?.(\n        new CustomEvent('subscription-state-change', { detail: { state: this.#statusOfSubscriptions.get(id)! } }),\n      );\n    } else if (currentState !== state) {\n      this.#statusOfSubscriptions.set(id, state);\n      this.#onStateChangeCallbacks.get(id)?.(\n        new CustomEvent('subscription-state-change', { detail: { state: this.#statusOfSubscriptions.get(id)! } }),\n      );\n    }\n  }\n\n  #handleMessage(message: unknown) {\n    if (isClientMessage(message)) {\n      const { id } = message;\n      const endpointInfo = this.#endpointInfos.get(id);\n\n      if (message['@type'] === 'update') {\n        const callback = this.#onNextCallbacks.get(id);\n        if (callback) {\n          callback(message.item);\n        }\n        this.#setSubscriptionConnState(id, FluxSubscriptionState.CONNECTED);\n      } else if (message['@type'] === 'complete') {\n        this.#onCompleteCallbacks.get(id)?.();\n        this.#removeSubscription(id);\n      } else {\n        const callback = this.#onErrorCallbacks.get(id);\n        if (callback) {\n          callback(message.message);\n        }\n        this.#removeSubscription(id);\n        if (!callback) {\n          throw new Error(\n            endpointInfo\n              ? `Error in ${endpointInfo.endpointName}.${endpointInfo.methodName}(${JSON.stringify(endpointInfo.params)}): ${message.message}`\n              : `Error in unknown subscription: ${message.message}`,\n          );\n        }\n      }\n    } else {\n      throw new Error(`Unknown message from server: ${String(message)}`);\n    }\n  }\n\n  #removeSubscription(id: string) {\n    this.#setSubscriptionConnState(id, FluxSubscriptionState.CLOSED);\n    this.#statusOfSubscriptions.delete(id);\n    this.#onStateChangeCallbacks.delete(id);\n    this.#onNextCallbacks.delete(id);\n    this.#onCompleteCallbacks.delete(id);\n    this.#onErrorCallbacks.delete(id);\n    this.#endpointInfos.delete(id);\n  }\n\n  #send(message: ServerMessage) {\n    if (this.state === State.INACTIVE) {\n      this.#pendingMessages.push(message);\n    } else {\n      this.#socket?.push?.(JSON.stringify(message));\n    }\n  }\n\n  #sendPendingMessages() {\n    this.#pendingMessages.forEach((msg) => this.#send(msg));\n    this.#pendingMessages = [];\n  }\n}\n\nexport interface FluxConnection {\n  addEventListener<T extends keyof EventMap>(type: T, listener: ListenerType<T>): void;\n  removeEventListener<T extends keyof EventMap>(type: T, listener: ListenerType<T>): void;\n}\n"],"version":3}