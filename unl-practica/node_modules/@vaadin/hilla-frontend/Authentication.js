import CookieManager from "./CookieManager.js";
import { getSpringCsrfInfo, getSpringCsrfTokenHeadersForAuthRequest, getSpringCsrfTokenParametersForAuthRequest, VAADIN_CSRF_HEADER } from "./CsrfUtils.js";
const JWT_COOKIE_NAME = "jwt.headerAndPayload";
function getSpringCsrfTokenFromResponseBody(body) {
	const doc = new DOMParser().parseFromString(body, "text/html");
	return getSpringCsrfInfo(doc);
}
function clearSpringCsrfMetaTags() {
	Array.from(document.head.querySelectorAll("meta[name=\"_csrf\"], meta[name=\"_csrf_header\"], meta[name=\"_csrf_parameter\"]")).forEach((el) => el.remove());
}
function updateSpringCsrfMetaTags(springCsrfInfo) {
	clearSpringCsrfMetaTags();
	const headerNameMeta = document.createElement("meta");
	headerNameMeta.name = "_csrf_header";
	headerNameMeta.content = springCsrfInfo._csrf_header;
	document.head.appendChild(headerNameMeta);
	const tokenMeta = document.createElement("meta");
	tokenMeta.name = "_csrf";
	tokenMeta.content = springCsrfInfo._csrf;
	document.head.appendChild(tokenMeta);
}
const getVaadinCsrfTokenFromResponseBody = (body) => {
	const match = /window\.Vaadin = \{TypeScript: \{"csrfToken":"([0-9a-zA-Z\\-]{36})"\}\};/iu.exec(body);
	return match ? match[1] : undefined;
};
async function updateCsrfTokensBasedOnResponse(response) {
	const responseText = await response.text();
	const token = getVaadinCsrfTokenFromResponseBody(responseText);
	const springCsrfTokenInfo = getSpringCsrfTokenFromResponseBody(responseText);
	updateSpringCsrfMetaTags(springCsrfTokenInfo);
	return token;
}
async function doFetchLogout(logoutUrl, headers) {
	const response = await fetch(logoutUrl, {
		headers,
		method: "POST"
	});
	if (!response.ok) {
		throw new Error(`failed to logout with response ${response.status}`);
	}
	await updateCsrfTokensBasedOnResponse(response);
	return response;
}
function doFormLogout(url, parameters) {
	const logoutUrl = typeof url === "string" ? url : url.toString();
	const form = document.createElement("form");
	form.setAttribute("method", "POST");
	form.setAttribute("action", logoutUrl);
	form.style.display = "none";
	for (const [name, value] of Object.entries(parameters)) {
		const input = document.createElement("input");
		input.setAttribute("type", "hidden");
		input.setAttribute("name", name);
		input.setAttribute("value", value);
		form.appendChild(input);
	}
	document.body.appendChild(form);
	form.submit();
}
async function doLogout(doc, options) {
	const shouldSubmitFormLogout = !options?.navigate && !options?.onSuccess;
	const logoutUrl = options?.logoutUrl ?? "logout";
	if (shouldSubmitFormLogout) {
		const parameters = getSpringCsrfTokenParametersForAuthRequest(doc);
		doFormLogout(logoutUrl, parameters);
		return new Response(undefined, {
			status: 200,
			statusText: "OK"
		});
	}
	const headers = getSpringCsrfTokenHeadersForAuthRequest(doc);
	return await doFetchLogout(logoutUrl, headers);
}
function normalizePath(url) {
	const effectiveBaseURL = new URL(".", document.baseURI);
	const effectiveBaseURI = effectiveBaseURL.toString();
	let normalized = url;
	if (normalized.startsWith(effectiveBaseURL.pathname)) {
		return `/${normalized.slice(effectiveBaseURL.pathname.length)}`;
	}
	normalized = normalized.startsWith(effectiveBaseURI) ? `/${normalized.slice(effectiveBaseURI.length)}` : normalized;
	return normalized;
}
/**
* Navigates to the provided path using page reload.
*
* @param to - navigation target path
*/
function navigateWithPageReload(to) {
	const url = to.startsWith("/") ? new URL(`.${to}`, document.baseURI) : to;
	window.location.replace(url);
}
/**
* A helper method for Spring Security based form login.
* @param username - username
* @param password - password
* @param options - defines additional options, e.g, the loginProcessingUrl etc.
*/
export async function login(username, password, options) {
	try {
		const data = new FormData();
		data.append("username", username);
		data.append("password", password);
		const loginProcessingUrl = options?.loginProcessingUrl ?? "login";
		const headers = getSpringCsrfTokenHeadersForAuthRequest(document);
		headers.source = "typescript";
		const response = await fetch(loginProcessingUrl, {
			body: data,
			headers,
			method: "POST"
		});
		const result = response.headers.get("Result");
		const savedUrl = response.headers.get("Saved-url") ?? undefined;
		const defaultUrl = response.headers.get("Default-url") ?? undefined;
		const loginSuccessful = response.ok && result === "success";
		if (loginSuccessful) {
			const vaadinCsrfToken = response.headers.get("Vaadin-CSRF") ?? undefined;
			const springCsrfHeader = response.headers.get("Spring-CSRF-header") ?? undefined;
			const springCsrfToken = response.headers.get("Spring-CSRF-token") ?? undefined;
			if (springCsrfHeader && springCsrfToken) {
				const springCsrfTokenInfo = {};
				springCsrfTokenInfo._csrf = springCsrfToken;
				springCsrfTokenInfo._csrf_header = springCsrfHeader;
				updateSpringCsrfMetaTags(springCsrfTokenInfo);
			}
			if (options?.onSuccess) {
				await options.onSuccess();
			}
			const url = savedUrl ?? defaultUrl ?? document.baseURI;
			const toPath = normalizePath(url);
			const navigate = options?.navigate ?? navigateWithPageReload;
			navigate(toPath);
			return {
				defaultUrl,
				error: false,
				redirectUrl: savedUrl,
				token: vaadinCsrfToken
			};
		}
		return {
			error: true,
			errorMessage: "Check that you have entered the correct username and password and try again.",
			errorTitle: "Incorrect username or password."
		};
	} catch (e) {
		if (e instanceof Error) {
			return {
				error: true,
				errorMessage: e.message,
				errorTitle: e.name
			};
		}
		throw e;
	}
}
/**
* A helper method for Spring Security based form logout
* @param options - defines additional options, e.g, the logoutUrl.
*/
export async function logout(options) {
	let response;
	try {
		response = await doLogout(document, options);
	} catch {
		try {
			const noCacheResponse = await fetch("?nocache");
			const responseText = await noCacheResponse.text();
			const doc = new DOMParser().parseFromString(responseText, "text/html");
			response = await doLogout(doc, options);
		} catch (error) {
			clearSpringCsrfMetaTags();
			throw error;
		}
	} finally {
		CookieManager.remove(JWT_COOKIE_NAME);
		if (response && response.ok && response.redirected) {
			if (options?.onSuccess) {
				await options.onSuccess();
			}
			const toPath = normalizePath(response.url);
			const navigate = options?.navigate ?? navigateWithPageReload;
			navigate(toPath);
		}
	}
}
/**
* A helper class for handling invalid sessions during an endpoint call.
* E.g., you can use this to show user a login page when the session has
* expired.
*/
export class InvalidSessionMiddleware {
	onInvalidSessionCallback;
	constructor(onInvalidSessionCallback) {
		this.onInvalidSessionCallback = onInvalidSessionCallback;
	}
	async invoke(context, next) {
		const clonedContext = { ...context };
		clonedContext.request = context.request.clone();
		const response = await next(context);
		if (response.status === 401) {
			const loginResult = await this.onInvalidSessionCallback();
			if (loginResult.token) {
				clonedContext.request.headers.set(VAADIN_CSRF_HEADER, loginResult.token);
				return next(clonedContext);
			}
		}
		return response;
	}
}
//# sourceMappingURL=./Authentication.js.map