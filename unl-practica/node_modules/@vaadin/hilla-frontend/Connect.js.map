{"mappings":"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","names":["response: Response","errorJson: ConnectExceptionData | null","obj: Record<string, unknown>","prop: unknown","path: string","options: ConnectClientOptions","#fluxConnection","endpoint: string","method: string","params?: Record<string, unknown>","init?: EndpointRequestInit","headers: Record<string, string>","initialContext: MiddlewareContext","context: MiddlewareContext","next: MiddlewareNext","value: any","error: unknown","params?: any"],"sources":["/opt/agent/work/1af72d8adc613024/hilla/packages/ts/frontend/src/Connect.ts"],"sourcesContent":["import type { ReactiveControllerHost } from '@lit/reactive-element';\nimport { ConnectionIndicator, ConnectionState } from '@vaadin/common-frontend';\nimport { getCsrfTokenHeadersForEndpointRequest } from './CsrfUtils.js';\nimport {\n  EndpointError,\n  EndpointResponseError,\n  EndpointValidationError,\n  ForbiddenResponseError,\n  UnauthorizedResponseError,\n  type ValidationErrorData,\n} from './EndpointErrors.js';\nimport {\n  type ActionOnLostSubscription,\n  FluxConnection,\n  type FluxSubscriptionStateChangeEvent,\n} from './FluxConnection.js';\nimport type { VaadinGlobal } from './types.js';\n\nconst $wnd = globalThis as VaadinGlobal;\n\n$wnd.Vaadin ??= {};\n$wnd.Vaadin.registrations ??= [];\n$wnd.Vaadin.registrations.push({\n  is: 'endpoint',\n});\n\nexport const BODY_PART_NAME = 'hilla_body_part';\n\nexport type MaybePromise<T> = Promise<T> | T;\n\n/**\n * Represents the connection to and endpoint returning a subscription rather than a value.\n */\nexport interface Subscription<T> {\n  /** Cancels the subscription.  No values are made available after calling this. */\n  cancel(): void;\n\n  /*\n   * Binds to the given context (element) so that when the context is deactivated (element detached), the subscription is closed.\n   */\n  context(context: ReactiveControllerHost): Subscription<T>;\n\n  /** Called when the subscription has completed. No values are made available after calling this. */\n  onComplete(callback: () => void): Subscription<T>;\n\n  /** Called when an exception occured in the subscription. */\n  onError(callback: (message: string) => void): Subscription<T>;\n\n  /** Called when a new value is available. */\n  onNext(callback: (value: T) => void): Subscription<T>;\n\n  /** Called when the subscription state changes. */\n  onConnectionStateChange(callback: (event: FluxSubscriptionStateChangeEvent) => void): Subscription<T>;\n\n  /**\n   * Called when the connection is restored, but there's no longer a valid subscription. If the callback returns\n   * `ActionOnLostSubscription.RESUBSCRIBE`, the subscription will be re-established by connecting to the same\n   * server method again. If the callback returns `ActionOnLostSubscription.REMOVE`, the subscription will be\n   * forgotten. This is also the default behavior if the callback is not set or if it returns `undefined`.\n   */\n  onSubscriptionLost(callback: () => ActionOnLostSubscription | void): Subscription<T>;\n}\n\ninterface ConnectExceptionData {\n  detail?: any;\n  message: string;\n  type: string;\n  validationErrorData?: ValidationErrorData[];\n}\n\n/**\n * Throws a TypeError if the response is not 200 OK.\n * @param response - The response to assert.\n */\nconst assertResponseIsOk = async (response: Response): Promise<void> => {\n  if (!response.ok) {\n    const errorText = await response.text();\n    let errorJson: ConnectExceptionData | null;\n    try {\n      errorJson = JSON.parse(errorText);\n    } catch {\n      // not a json\n      errorJson = null;\n    }\n\n    const message =\n      errorJson?.message ??\n      (errorText.length > 0\n        ? errorText\n        : `expected \"200 OK\" response, but got ${response.status} ${response.statusText}`);\n    const type = errorJson?.type;\n\n    if (errorJson?.validationErrorData) {\n      throw new EndpointValidationError(message, errorJson.validationErrorData, type);\n    }\n\n    if (type) {\n      throw new EndpointError(message, type, errorJson?.detail);\n    }\n\n    switch (response.status) {\n      case 401:\n        throw new UnauthorizedResponseError(message, response);\n      case 403:\n        throw new ForbiddenResponseError(message, response);\n      default:\n        throw new EndpointResponseError(message, response);\n    }\n  }\n};\n\n/**\n * The `ConnectClient` constructor options.\n */\nexport interface ConnectClientOptions {\n  /**\n   * The `middlewares` property value.\n   */\n  middlewares?: Middleware[];\n  /**\n   * The `prefix` property value.\n   */\n  prefix?: string;\n  /**\n   * The Atmosphere options for the FluxConnection.\n   */\n  atmosphereOptions?: Partial<Atmosphere.Request>;\n}\n\nexport interface EndpointCallMetaInfo {\n  /**\n   * The endpoint name.\n   */\n  endpoint: string;\n\n  /**\n   * The method name to call on in the endpoint class.\n   */\n  method: string;\n\n  /**\n   * Optional object with method call arguments.\n   */\n  params?: Record<string, unknown>;\n}\n\n/**\n * An object with the call arguments and the related Request instance.\n * See also {@link ConnectClient.call | the call() method in ConnectClient}.\n */\nexport interface MiddlewareContext extends EndpointCallMetaInfo {\n  /**\n   * The Fetch API Request object reflecting the other properties.\n   */\n  request: Request;\n}\n\n/**\n * An async middleware callback that invokes the next middleware in the chain\n * or makes the actual request.\n * @param context - The information about the call and request\n */\nexport type MiddlewareNext = (context: MiddlewareContext) => MaybePromise<Response>;\n\n/**\n * An interface that allows defining a middleware as a class.\n */\nexport interface MiddlewareClass {\n  /**\n   * @param context - The information about the call and request\n   * @param next - Invokes the next in the call chain\n   */\n  invoke(context: MiddlewareContext, next: MiddlewareNext): MaybePromise<Response>;\n}\n\n/**\n * An async callback function that can intercept the request and response\n * of a call.\n */\nexport type MiddlewareFunction = (context: MiddlewareContext, next: MiddlewareNext) => MaybePromise<Response>;\n\n/**\n * An async callback that can intercept the request and response\n * of a call, could be either a function or a class.\n */\nexport type Middleware = MiddlewareClass | MiddlewareFunction;\n\nfunction isFlowLoaded(): boolean {\n  return $wnd.Vaadin?.Flow?.clients?.TypeScript !== undefined;\n}\n\n/**\n * Extracts file objects from the object that is used to build the request body.\n *\n * @param obj - The object to extract files from.\n * @returns A tuple with the object without files and a map of files.\n */\nfunction extractFiles(obj: Record<string, unknown>): [Record<string, unknown>, Map<string, File>] {\n  const fileMap = new Map<string, File>();\n\n  function recursiveExtract(prop: unknown, path: string): unknown {\n    if (prop !== null && typeof prop === 'object') {\n      if (prop instanceof File) {\n        fileMap.set(path, prop);\n        return null;\n      }\n      if (Array.isArray(prop)) {\n        return prop.map((item, index) => recursiveExtract(item, `${path}/${index}`));\n      }\n      return Object.entries(prop).reduce<Record<string, unknown>>((acc, [key, value]) => {\n        const newPath = `${path}/${key}`;\n        if (value instanceof File) {\n          fileMap.set(newPath, value);\n        } else {\n          acc[key] = recursiveExtract(value, newPath);\n        }\n        return acc;\n      }, {});\n    }\n    return prop;\n  }\n\n  return [recursiveExtract(obj, '') as Record<string, unknown>, fileMap];\n}\n\n/**\n * A list of parameters supported by {@link ConnectClient.call | the call() method in ConnectClient}.\n */\nexport interface EndpointRequestInit {\n  /**\n   * An AbortSignal to set request's signal.\n   */\n  signal?: AbortSignal | null;\n  /**\n   * If set to true, the connection state will not be updated during the request.\n   */\n  mute?: boolean;\n}\n\n/**\n * A low-level network calling utility. It stores\n * a prefix and facilitates remote calls to endpoint class methods\n * on the Hilla backend.\n *\n * Example usage:\n *\n * ```js\n * const client = new ConnectClient();\n * const responseData = await client.call('MyEndpoint', 'myMethod');\n * ```\n *\n * ### Prefix\n *\n * The client supports an `prefix` constructor option:\n * ```js\n * const client = new ConnectClient({prefix: '/my-connect-prefix'});\n * ```\n *\n * The default prefix is '/connect'.\n *\n */\nexport class ConnectClient {\n  /**\n   * The array of middlewares that are invoked during a call.\n   */\n  middlewares: Middleware[] = [];\n  /**\n   * The Hilla endpoint prefix\n   */\n  prefix = '/connect';\n  /**\n   * The Atmosphere options for the FluxConnection.\n   */\n  atmosphereOptions: Partial<Atmosphere.Request> = {};\n\n  #fluxConnection?: FluxConnection;\n\n  /**\n   * @param options - Constructor options.\n   */\n  constructor(options: ConnectClientOptions = {}) {\n    if (options.prefix) {\n      this.prefix = options.prefix;\n    }\n\n    if (options.middlewares) {\n      this.middlewares = options.middlewares;\n    }\n\n    if (options.atmosphereOptions) {\n      this.atmosphereOptions = options.atmosphereOptions;\n    }\n\n    // add connection indicator to DOM\n    ConnectionIndicator.create();\n\n    // Listen to browser online/offline events and update the loading indicator accordingly.\n    // Note: if Flow.ts is loaded, it instead handles the state transitions.\n    addEventListener('online', () => {\n      if (!isFlowLoaded() && $wnd.Vaadin?.connectionState) {\n        $wnd.Vaadin.connectionState.state = ConnectionState.CONNECTED;\n      }\n    });\n    addEventListener('offline', () => {\n      if (!isFlowLoaded() && $wnd.Vaadin?.connectionState) {\n        $wnd.Vaadin.connectionState.state = ConnectionState.CONNECTION_LOST;\n      }\n    });\n  }\n\n  /**\n   * Gets a representation of the underlying persistent network connection used for subscribing to Flux type endpoint\n   * methods.\n   */\n  get fluxConnection(): FluxConnection {\n    if (!this.#fluxConnection) {\n      this.#fluxConnection = new FluxConnection(this.prefix, this.atmosphereOptions);\n    }\n    return this.#fluxConnection;\n  }\n\n  /**\n   * Calls the given endpoint method defined using the endpoint and method\n   * parameters with the parameters given as params.\n   * Asynchronously returns the parsed JSON response data.\n   *\n   * @param endpoint - Endpoint name.\n   * @param method - Method name to call in the endpoint class.\n   * @param params - Optional parameters to pass to the method.\n   * @param init - Optional parameters for the request\n   * @returns Decoded JSON response data.\n   */\n  async call(\n    endpoint: string,\n    method: string,\n    params?: Record<string, unknown>,\n    init?: EndpointRequestInit,\n  ): Promise<any> {\n    if (arguments.length < 2) {\n      throw new TypeError(`2 arguments required, but got only ${arguments.length}`);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const csrfHeaders = globalThis.document ? getCsrfTokenHeadersForEndpointRequest(globalThis.document) : {};\n    const headers: Record<string, string> = {\n      Accept: 'application/json',\n      ...csrfHeaders,\n    };\n\n    const [paramsWithoutFiles, files] = extractFiles(params ?? {});\n    let body;\n\n    if (files.size > 0) {\n      // in this case params is not undefined, otherwise there would be no files\n      body = new FormData();\n      body.append(\n        BODY_PART_NAME,\n        JSON.stringify(paramsWithoutFiles, (_, value) => (value === undefined ? null : value)),\n      );\n\n      for (const [path, file] of files) {\n        body.append(path, file);\n      }\n    } else {\n      headers['Content-Type'] = 'application/json';\n      if (params) {\n        body = JSON.stringify(params, (_, value) => (value === undefined ? null : value));\n      }\n    }\n\n    const request = new Request(`${this.prefix}/${endpoint}/${method}`, {\n      body, // automatically sets Content-Type header\n      headers,\n      method: 'POST',\n    });\n\n    // The middleware `context`, includes the call arguments and the request\n    // constructed from them\n    const initialContext: MiddlewareContext = {\n      endpoint,\n      method,\n      params,\n      request,\n    };\n\n    // The internal middleware to assert and parse the response. The internal\n    // response handling should come last after the other middlewares are done\n    // with processing the response. That is why this middleware is first\n    // in the final middlewares array.\n    async function responseHandlerMiddleware(context: MiddlewareContext, next: MiddlewareNext): Promise<Response> {\n      const response = await next(context);\n      await assertResponseIsOk(response);\n      const text = await response.text();\n      return JSON.parse(text, (_, value: any) => (value === null ? undefined : value));\n    }\n\n    // The actual fetch call itself is expressed as a middleware\n    // chain item for our convenience. Always having an ending of the chain\n    // this way makes the folding down below more concise.\n    async function fetchNext(context: MiddlewareContext) {\n      // if the request is not \"muted\", notify the connection state about changes\n      const connectionState = init?.mute ? undefined : $wnd.Vaadin?.connectionState;\n      connectionState?.loadingStarted();\n      try {\n        const response = await fetch(context.request, { signal: init?.signal });\n        connectionState?.loadingFinished();\n        return response;\n      } catch (error: unknown) {\n        // don't bother about connections aborted by purpose\n        if (error instanceof Error && error.name === 'AbortError') {\n          connectionState?.loadingFinished();\n        } else {\n          connectionState?.loadingFailed();\n        }\n        throw error;\n      }\n    }\n\n    // Assemble the final middlewares array from internal\n    // and external middlewares\n    const middlewares = [responseHandlerMiddleware as Middleware, ...this.middlewares];\n\n    // Fold the final middlewares array into a single function\n    const chain = middlewares.reduceRight(\n      (next: MiddlewareNext, middleware) =>\n        // Compose and return the new chain step, that takes the context and\n        // invokes the current middleware with the context and the further chain\n        // as the next argument\n        async (context) => {\n          if (typeof middleware === 'function') {\n            return middleware(context, next);\n          }\n          return middleware.invoke(context, next);\n        },\n      // Initialize reduceRight the accumulator with `fetchNext`\n      fetchNext,\n    );\n\n    // Invoke all the folded async middlewares and return\n    return chain(initialContext);\n  }\n\n  /**\n   * Subscribes to the given method defined using the endpoint and method\n   * parameters with the parameters given as params. The method must return a\n   * compatible type such as a Flux.\n   * Returns a subscription that is used to fetch values as they become available.\n   *\n   * @param endpoint - Endpoint name.\n   * @param method - Method name to call in the endpoint class.\n   * @param params - Optional parameters to pass to the method.\n   * @returns A subscription used to handles values as they become available.\n   */\n  subscribe(endpoint: string, method: string, params?: any): Subscription<any> {\n    return this.fluxConnection.subscribe(endpoint, method, params ? Object.values(params) : []);\n  }\n}\n"],"version":3}